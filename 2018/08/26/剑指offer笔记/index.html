<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="面试题主页：http://zhedahht.blog.163.com/">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指offer笔记">
<meta property="og:url" content="ztzhang.cn/2018/08/26/剑指offer笔记/index.html">
<meta property="og:site_name" content="KingSoul&#39;s Garden">
<meta property="og:description" content="面试题主页：http://zhedahht.blog.163.com/">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="/2018/08/26/剑指offer笔记/重建的二叉树.jpg">
<meta property="og:image" content="/2018/08/26/剑指offer笔记/分析.jpg">
<meta property="og:image" content="/2018/08/26/剑指offer笔记/机器人路径.jpg">
<meta property="og:image" content="/2018/08/26/剑指offer笔记/1.png">
<meta property="og:updated_time" content="2018-09-05T03:12:22.424Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="剑指offer笔记">
<meta name="twitter:description" content="面试题主页：http://zhedahht.blog.163.com/">
<meta name="twitter:image" content="/2018/08/26/剑指offer笔记/重建的二叉树.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="ztzhang.cn/2018/08/26/剑指offer笔记/"/>





  <title>剑指offer笔记 | KingSoul's Garden</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">KingSoul's Garden</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            日程表
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="ztzhang.cn/2018/08/26/剑指offer笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KingSoul">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KingSoul's Garden">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">剑指offer笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-26T18:34:50+08:00">
                2018-08-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  10,955
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  48
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>面试题主页：<a href="http://zhedahht.blog.163.com/" target="_blank" rel="noopener">http://zhedahht.blog.163.com/</a><br><a id="more"></a></p>
<h2 id="Java内存的堆和栈"><a href="#Java内存的堆和栈" class="headerlink" title="Java内存的堆和栈"></a>Java内存的堆和栈</h2><ul>
<li>堆中存放对象 </li>
<li>栈中存放对象的引用</li>
</ul>
<h2 id="JVM内存区域的划分"><a href="#JVM内存区域的划分" class="headerlink" title="JVM内存区域的划分"></a>JVM内存区域的划分</h2><p>资料</p>
<ul>
<li><a href="https://www.cnblogs.com/cherryljr/p/6230380.html" target="_blank" rel="noopener">https://www.cnblogs.com/cherryljr/p/6230380.html</a></li>
<li><a href="http://blog.holten.site/2016/04/09/JVM-memory-area/" target="_blank" rel="noopener">http://blog.holten.site/2016/04/09/JVM-memory-area/</a><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3></li>
</ul>
<h2 id="参数的值传递与引用传递"><a href="#参数的值传递与引用传递" class="headerlink" title="参数的值传递与引用传递"></a>参数的值传递与引用传递</h2><p><a href="https://github.com/nnngu/LearningNotes/blob/master/Java%20Basis/007%20Java%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92.md" target="_blank" rel="noopener">https://github.com/nnngu/LearningNotes/blob/master/Java%20Basis/007%20Java%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92.md</a></p>
<ul>
<li>按值传递：值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。简单来说就是直接复制了一份数据过去，因为是直接复制，所以这种方式在传递时如果数据量非常大的话，运行效率自然就变低了，所以java在传递数据量很小的数据是值传递，比如java中的各种基本类型。</li>
<li>按引用传递：引用传递其实就弥补了上面说的不足，如果每次传参数的时候都复制一份的话，如果这个参数占用的内存空间太大的话，运行效率会很底下，所以引用传递就是直接把内存地址传过去，也就是说引用传递时，操作的其实都是源数据，这样的话修改有时候会冲突，记得用逻辑弥补下就好了，具体的数据类型就比较多了，比如Object，二维数组，List，Map等除了基本类型的参数都是引用传递。<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    private static void foo(int value) &#123;</span><br><span class="line">        value = 100;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int num=1;</span><br><span class="line">        foo(num);</span><br><span class="line">        System.out.print(&quot;num :&quot;+num);//num没有改变</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">输出：num :1</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">	static void foo(String text) &#123;</span><br><span class="line">	        text = &quot;windows&quot;;</span><br><span class="line">	    &#125;</span><br><span class="line">	public static void main(String[] args)&#123; </span><br><span class="line">		String str=&quot;Hello World&quot;;</span><br><span class="line">        foo(str);</span><br><span class="line">        System.out.print(&quot;str :&quot;+str);//str没有变</span><br><span class="line">	&#125;   </span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">输出：str:Hello World</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">	static void foo(StringBuilder builder) &#123;</span><br><span class="line">	    builder.append(&quot;4&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">	public static void main(String[] args)&#123; </span><br><span class="line">		StringBuilder str = new StringBuilder(&quot;iphone&quot;);</span><br><span class="line">        foo(str);</span><br><span class="line">        System.out.print(&quot;str :&quot;+str);//str发生改变</span><br><span class="line">	&#125;   </span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">输出：str:iphone4</span><br><span class="line">*/ </span><br><span class="line">void foo(StringBuilder builder) &#123;</span><br><span class="line">    builder.append(&quot;4&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="什么是哈希表？"><a href="#什么是哈希表？" class="headerlink" title="什么是哈希表？"></a>什么是哈希表？</h3><p>数组和向量都可以存储对象，但对象的存储位置是随机的，也就是说对象本身与其存储位置之间没有必然的联系。当要查找一个对象时，只能以某种顺序（如顺序查找或二分查找）与各个元素进行比较，当数组或向量中的元素数量很多时，查找的效率会明显的降低。</p>
<p>一种有效的存储方式，是不与其他元素进行比较，一次存取便能得到所需要的记录。这就需要在对象的存储位置和对象的关键属性（设为 k）之间建立一个特定的对应关系（设为 f），使每个对象与一个唯一的存储位置相对应。在查找时，只要根据待查对象的关键属性 k 计算f(k)的值即可。如果此对象在集合中，则必定在存储位置 f(k)上，因此不需要与集合中的其他元素进行比较。称这种对应关系 f 为哈希（hash）方法，按照这种思想建立的表为哈希表。</p>
<h3 id="使用哈希表的例子"><a href="#使用哈希表的例子" class="headerlink" title="使用哈希表的例子"></a>使用哈希表的例子</h3><h4 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a>第一个只出现一次的字符</h4><p>描述：在字符串中找出第一个只出现一次的字符。如输入”abaccdeff”，则输出”b”;</p>
<p>思路：定义哈希表的key是字符，value是该字符出现的次数；则只需扫描两次字符串，第一次扫描时，将哈希表对应的键和值搞定，第二次扫描时，每扫描一个字符就可以在哈希表中得到次数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//1:</span><br><span class="line">public static int FirstNotRepeatingChar(String str) &#123;</span><br><span class="line">		 int[] hash=new int[256];</span><br><span class="line">		 int len=str.length();</span><br><span class="line">		 for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">			 char temp=str.charAt(i);</span><br><span class="line">			 //每个字母根据其ASCII码值作为数组下标对应该字符出现的次数</span><br><span class="line">			 hash[temp]++;</span><br><span class="line">		 &#125;</span><br><span class="line">		 int i;</span><br><span class="line">		 for(i=0;i&lt;len;i++)&#123;</span><br><span class="line">			 char temp=str.charAt(i);</span><br><span class="line">			 if(hash[temp]==1)</span><br><span class="line">				 return i;</span><br><span class="line">		 &#125;</span><br><span class="line">	        return -1;</span><br><span class="line">&#125;</span><br><span class="line">//2</span><br><span class="line">public Character firstNotRepeating(String str)&#123;</span><br><span class="line">		if(str == null)</span><br><span class="line">			return null;</span><br><span class="line">		char[] strChar = str.toCharArray();</span><br><span class="line">		LinkedHashMap&lt;Character,Integer&gt; hash = new LinkedHashMap&lt;Character,Integer&gt;();</span><br><span class="line">		for(char item:strChar)&#123;</span><br><span class="line">			if(hash.containsKey(item))</span><br><span class="line">				hash.put(item, hash.get(item)+1);</span><br><span class="line">			else</span><br><span class="line">				hash.put(item, 1);</span><br><span class="line">		&#125;</span><br><span class="line">		for(char key:hash.keySet())</span><br><span class="line">		&#123;</span><br><span class="line">			if(hash.get(key)== 1)</span><br><span class="line">				return key;</span><br><span class="line">		&#125;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="关于数组的面试题"><a href="#关于数组的面试题" class="headerlink" title="关于数组的面试题"></a>关于数组的面试题</h2><h3 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h3><p>描述：在长度为n的数组里所有的数字都在0~n-1的范围内，数组中有这些数字是重复出现的，但是不知道有几个数字重复了，也不知道重复了几次，求找出任意一个重复的数字；</p>
<h4 id="用哈希表"><a href="#用哈希表" class="headerlink" title="用哈希表"></a>用哈希表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从头到尾扫描数组中的每一个数字，没扫描到一个数字的时候，都可以用O(1)的时间来判断哈希表中是否存在这个数字。如果没有这个数字，就将他放到哈希表中，反之就找到了一个数字，结束寻找；算法时间是O(n),还有个大小为O(n)的哈希表；</span><br></pre></td></tr></table></figure>
<h4 id="更有效的方法"><a href="#更有效的方法" class="headerlink" title="更有效的方法"></a>更有效的方法</h4><p>思路：假设数组为a,现在我们重排数组，当扫描到a[i]时，先判断(a[i]==i)?true:false;如果为true，则i+1,扫描下一个数，反之，假设a[i]=m,(m!=i),先比较a[m]= =a[i]?true:false,如果true,我们就找到了一个重复数字，反之，我们就交换这两个数字（相当于把m放到了属于他的位置）；接下来在继续重复这些步骤；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static boolean duplicate(int []num)&#123;</span><br><span class="line"></span><br><span class="line">        if(num==null||num.length&lt;=0) return false;</span><br><span class="line">        int len=num.length;</span><br><span class="line">        for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">            if(num[i]&lt;0||num[i]&gt;len-1)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">            while(num[i]!=i)&#123;</span><br><span class="line">                if(num[i]==num[num[i]])&#123;</span><br><span class="line">                    System.out.println(num[i]);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    int temp = num[num[i]];</span><br><span class="line">                    num[num[i]]=num[i];</span><br><span class="line">                    num[i] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="不修改数组找数组中重复的数字"><a href="#不修改数组找数组中重复的数字" class="headerlink" title="不修改数组找数组中重复的数字"></a>不修改数组找数组中重复的数字</h4><h3 id="旋转数组中的最小数字"><a href="#旋转数组中的最小数字" class="headerlink" title="旋转数组中的最小数字"></a>旋转数组中的最小数字</h3><p>描述：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。</p>
<p>思路：二分法；我们用两个指针分别指向数组的第一个元素和最后一个元素。按照旋转规则，第一个元素应该大于等于最后一个元素。接着可以找到数组中间的元素。如果中间元素位于前面的递增数组，则它应该大于等于第一个指针指向的元素，此时我们要找到的最小元素肯定应该位于该中间元素的后面。这样我们把第一个指针指向中间元素，从而缩小查找范围。注意，移动之后的第一个指针仍然是位于前面的递增数组中。<br>同理，如果中间元素位于后面的递增子数组，那么它应该小于等于第二个指针指向的元素。此时最小元素应该位于中间元素的前面或者就是此中间元素。我们把第二个指针指向中间元素，从而缩小查找范围。注意，移动之后的第二个指针仍然是位于后面的递增数组中。<br>     按照上述思路，第一个指针总是指向前面的递增数组元素，而第二个指针总是指向后面的递增数组元素。最终第一个指针将指向前面的子数组的最后一个元素，第二个指针将指向后面的子数组的第一个元素，即二者最后指向相邻的元素，且第二个指针指向的刚好是最小的元素——循环结束条件。<br>     但是如果第一个指针指向的元素、第二个指针指向的元素和中间元素相同，则无法判断中间元素是属于哪个子数组，也就无法移动两个指针来缩小查找范围，此时还是要用顺序查找的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private static int solution(int[] array)&#123;</span><br><span class="line">        int low=0;</span><br><span class="line">        int high=array.length-1;</span><br><span class="line">        int middle=0;</span><br><span class="line">        while(high!=(low+1))&#123;</span><br><span class="line">            middle=(low+high)/2;</span><br><span class="line">            if(array[low]==array[middle]&amp;&amp;array[middle]==array[high])</span><br><span class="line">                return findMinInOrder(array,low,high);</span><br><span class="line"></span><br><span class="line">            if(array[middle]&gt;=array[low])&#123;</span><br><span class="line">                low=middle;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                high=middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return array[high];</span><br><span class="line">    &#125;</span><br><span class="line">    private static int findMinInOrder(int[] array,int indexLow,int indexHigh)&#123;</span><br><span class="line">        int result=array[indexLow];</span><br><span class="line">        for(int i=indexLow+1;i&lt;indexHigh;i++)&#123;</span><br><span class="line">                if(array[i]&lt;result)</span><br><span class="line">                        result=array[i];</span><br><span class="line">            &#125;</span><br><span class="line">                 return result;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<h3 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h3><p>描述：在一个二维数组中，每一行都是按照自从左到右递增的顺序，每一列都是按照从上到下的递增顺序，要求输入一个整数判断该整数是否在这个二维数组中；<br> 思路：假设数组为a[n][m],整数为k ，令row=0,col=m-1,我们先取该数组中的a[row][col]与k作比较，</p>
<ul>
<li>如果a[row][col]==k, 输出true;</li>
<li>如果a[row][col]&lt;k,说明在第row行的最大值都比k小，则淘汰第row行；比较a[row+1][col]与k的关系；</li>
<li>如果a[row] [col]&gt;k,说明第col列的最小值都比k大，则淘汰第col列；比较a[row][col-1];<br>重复以上步骤直到row= =n-1 || col==0</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private static boolean find(int[][]matrix,int x)&#123;</span><br><span class="line">       int rowIndex=0;</span><br><span class="line">       int columnIndex=matrix.length-1;</span><br><span class="line">       while(rowIndex&lt;matrix.length &amp;&amp; columnIndex&gt;=0)&#123;</span><br><span class="line">           if(matrix[rowIndex][columnIndex]== x)&#123;</span><br><span class="line">               return true;</span><br><span class="line">           &#125;else if(matrix[rowIndex][columnIndex]&lt;x)&#123;</span><br><span class="line">               rowIndex++;</span><br><span class="line">           &#125;else &#123;</span><br><span class="line">               columnIndex--;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>经验：当要处理的数组是有序数组时，一般使用二分法；</p>
<h3 id="在排序数组中查找数字"><a href="#在排序数组中查找数字" class="headerlink" title="在排序数组中查找数字"></a>在排序数组中查找数字</h3><h4 id="数字在排序数组中出现的次数"><a href="#数字在排序数组中出现的次数" class="headerlink" title="数字在排序数组中出现的次数"></a>数字在排序数组中出现的次数</h4><p>思路：利用二分法直接查找这个数字k的第一次和最后一次出现的位置<br>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private static int getFirstK(int[] array,int k)&#123;</span><br><span class="line">        int start=0;</span><br><span class="line">        int end=array.length-1;</span><br><span class="line">        int middle=(start+end)/2 ;</span><br><span class="line">        while(start&lt;=end)&#123;</span><br><span class="line">            if(array[middle]&gt;k)&#123;</span><br><span class="line">                end=middle-1;</span><br><span class="line">            &#125;else if(array[middle]&lt;k)&#123;</span><br><span class="line">                start=middle+1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                while (array[middle]==k)&#123;</span><br><span class="line">                    middle--;</span><br><span class="line">                &#125;</span><br><span class="line">                return middle+1;</span><br><span class="line">            &#125;</span><br><span class="line">            middle=(start+end)/2;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="0-n中缺失的数字"><a href="#0-n中缺失的数字" class="headerlink" title="0~n中缺失的数字"></a>0~n中缺失的数字</h4><p>描述： 一个长度为n递增排序的数组，数组上的数字的范围是0 ~ n,并且数组上的数字是唯一的，请找出这(n+1)个数字中不在数组上的数字；</p>
<h5 id="解法一-O-n"><a href="#解法一-O-n" class="headerlink" title="解法一: O(n)"></a>解法一: O(n)</h5><p>用公式求0~n这n+1个数的和，记为s1,接着求该数组上的所有数字的和，记为s2,则缺少的数字就是s1-s2;</p>
<h5 id="解法二：O-log2-n"><a href="#解法二：O-log2-n" class="headerlink" title="解法二：O(log2(n))"></a>解法二：O(log2(n))</h5><p>该数组的特殊性：a[i]=i;<br>等价与找出在这个数组中第一个a[i]!=i数字；<br>用二分法查找<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private static int getLost(int []a)&#123;</span><br><span class="line">        int start=0;</span><br><span class="line">        int end=a.length-1;</span><br><span class="line">        int middle=(start+end)/2;</span><br><span class="line">        while(start&lt;=end)&#123;</span><br><span class="line">            if(a[middle]==middle)&#123;</span><br><span class="line">                start=middle+1;</span><br><span class="line"></span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(a[middle-1]==middle-1)&#123;</span><br><span class="line">                    return middle;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    end=middle+1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            middle=(start+end)/2;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="数值与下标相等的元素"><a href="#数值与下标相等的元素" class="headerlink" title="数值与下标相等的元素"></a>数值与下标相等的元素</h4><p>二分法：</p>
<ul>
<li>假设到达第i个数字，如果a[i]==i,则找到一个元素</li>
<li>如果a[i]=m且m!=i,则<ul>
<li>a[i]&gt;i :根据数组递增的特性可知：a[i]以后的元素的值至少每个比前面大1，同时它们的下标每次也是增加1，从而右边的这些元素的值都大于它们的下标，因此需要继续在左边寻找</li>
<li>a[i]&lt;i:a[i]左边的那些元素的值也都小于它们的下标，因此需要继续在右边寻找<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private static int getNumberSameIndex(int []a)&#123;</span><br><span class="line">        int start=0;</span><br><span class="line">        int end=a.length-1;</span><br><span class="line"></span><br><span class="line">        while(start&lt;=end)&#123;</span><br><span class="line">            int midlle=(start+end)/2;</span><br><span class="line">            if(a[midlle]==midlle)&#123;</span><br><span class="line">               return midlle;</span><br><span class="line"></span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(a[midlle]&gt;midlle)&#123;</span><br><span class="line">                    end=midlle-1;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    start=midlle+1;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="数组中数字出现的次数"><a href="#数组中数字出现的次数" class="headerlink" title="数组中数字出现的次数"></a>数组中数字出现的次数</h3><h4 id="数组中只出现一次的两个数字"><a href="#数组中只出现一次的两个数字" class="headerlink" title="数组中只出现一次的两个数字"></a>数组中只出现一次的两个数字</h4><p>描述：一个整形数组里除了两个数字之外，其他数字都出现了两次，求输出这两个数字；要求时间复杂度为O(n),空间复杂度为O(1);</p>
<p>思路：如果这个数组中只有一个数没有出现两次，则使用任何两个相同的数字的异或为0这个性质，从头到尾异或数组中的每个数字，则最终的结果就是只出现一次的数字；<br>因此，解决这个问题的办法就是将这个 数组分为两个数组，每个数组只有一个只出现一次的数字！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private static int[] FindNumsApperaOnce(int []data)&#123;</span><br><span class="line">       int result[]=new int[]&#123;0,0&#125;;</span><br><span class="line">       if(data==null||data.length&lt;2) return null;</span><br><span class="line">       int bitResult=0;</span><br><span class="line">       //对所有的数字求异或运算</span><br><span class="line">       for(int i=0;i&lt;data.length;i++)&#123;</span><br><span class="line">           bitResult^=data[i];</span><br><span class="line">       &#125;</span><br><span class="line">       int index=FingFirstBitIs1(bitResult);</span><br><span class="line">       for(int i=0;i&lt;data.length;i++)&#123;</span><br><span class="line">           if(isBit1(data[i],index))&#123;</span><br><span class="line">               result[0]^=data[i];</span><br><span class="line">           &#125;else &#123;</span><br><span class="line">               result[1]^=data[i];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br><span class="line">   private static int FingFirstBitIs1(int num)&#123;</span><br><span class="line">       int index=0;</span><br><span class="line">       while((num&amp;1)==0&amp;&amp;index&lt;32)&#123;</span><br><span class="line">           num=num&gt;&gt;1;</span><br><span class="line">           index++;</span><br><span class="line">       &#125;</span><br><span class="line">       return index;</span><br><span class="line">   &#125;</span><br><span class="line">   /*</span><br><span class="line">   用于检测某个数的第index位是否为1；</span><br><span class="line">   */</span><br><span class="line">   private static boolean isBit1(int target, int index)&#123;</span><br><span class="line">       return ((target &gt;&gt; index) &amp; 1) == 1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="数组中唯一只出现一次的数字"><a href="#数组中唯一只出现一次的数字" class="headerlink" title="数组中唯一只出现一次的数字"></a>数组中唯一只出现一次的数字</h4><p>描述：一个数组中除一个数字只出现一次外，其他数字都出现了三次，求找出这个数；<br> 思路：如果一个数字出现三次，那么他的二进制表示的每一位（0,1）都出现了三次，那么每一位都会被3整除，因此，将所有的数字的二进制的每一位做加法，如果某一位能被3整除，那么所求的数的该位就为0，否则为1；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private static int find(int []nums)throws Exception&#123;</span><br><span class="line">        int len = nums.length;</span><br><span class="line">        int[] bits = new int[32];</span><br><span class="line">        for(int i = 0 ; i &lt; len; i++)</span><br><span class="line">            for(int j = 0; j &lt; 32; j++)</span><br><span class="line">                bits[j] += ((nums[i]&gt;&gt;j)&amp;1);</span><br><span class="line"></span><br><span class="line">        int result = 0;</span><br><span class="line">        for(int i = 0 ; i &lt; 32; i++)&#123;</span><br><span class="line">            if(bits[i] % 3 == 1) result += 1 &lt;&lt; i;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="和为s的数字"><a href="#和为s的数字" class="headerlink" title="和为s的数字"></a>和为s的数字</h3><p>描述：输入一个递增的数组和一个数字s，在数组中查找任意一对数使他们的和为s；</p>
<p>思路：使用两个指针start、end分别指向数组的前面和后面两个数，当这两个数的和小于s时，start向后一个位置；当这两个数的和大于s时，end向前移动一个位置；直到找到这两个数或者start==end；时间复杂度为O(n)；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private static int[] find(int [] data,int s)&#123;</span><br><span class="line">        int start=0,end=data.length-1;</span><br><span class="line">        if(data==null||data.length&lt;2) return null;</span><br><span class="line">        int[] result=null;</span><br><span class="line">        while(start&lt;end)&#123;</span><br><span class="line">            int a=data[start],b=data[end];</span><br><span class="line">            if(a+b&gt;s)&#123;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;else if(a+b&lt;s) &#123;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                result=new int[]&#123;a,b&#125;;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="和为s的连续正数序列"><a href="#和为s的连续正数序列" class="headerlink" title="和为s的连续正数序列"></a>和为s的连续正数序列</h3><p>描述： 输入一个正数s,打印出所有和为s的连续正数序列（至少含有两个数）<br>思路：由于序列是连续的，所以我们可以用两个指针small和big分别指向序列的最小值和最大值，比如序列{2,3,4,5}，此时small指向2，big指向5；当序列和小于s，时，我们可以增大big使得序列个数变多，此时序列变为{2,3,4,5,6}，big指向6；反之则增大small使得序列个数变少，此时序列为{3,4,5}；<br>当找到一个序列满足条件时，再增加big，重复之前的操作；因为序列要求要有两个数，我们一直增加small直到等于s/2为止；</p>
<p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private static ArrayList&lt;ArrayList&lt;Integer&gt;&gt; find(int s)&#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result=new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; list;</span><br><span class="line">        if(s&lt;3) return null;</span><br><span class="line">        int small=1,big=2;</span><br><span class="line">        while (small&lt;=s/2)&#123;</span><br><span class="line">            if(sum(small,big)==s)&#123;</span><br><span class="line">                list=getList(small,big);</span><br><span class="line">                result.add(list);</span><br><span class="line">                big++;</span><br><span class="line">            &#125;else if(sum(small,big)&gt;s)&#123;</span><br><span class="line">                small++;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                big++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    private  static int sum(int small,int big)&#123;</span><br><span class="line">        int sum=0;</span><br><span class="line">        while (small&lt;=big)&#123;</span><br><span class="line">            sum+=small;</span><br><span class="line">            small++;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">    private  static ArrayList&lt;Integer&gt; getList(int small,int big)&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list=new ArrayList&lt;&gt;();</span><br><span class="line">        if(small&gt;=big) return null;</span><br><span class="line">        while(small&lt;=big)&#123;</span><br><span class="line">            list.add(small);</span><br><span class="line">            small++;</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>以下代码在求和时减少了很多不必要的运算<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(int sum)</span><br><span class="line">    &#123;</span><br><span class="line">	  </span><br><span class="line">	  ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listall = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">			  if(sum &lt; 3)</span><br><span class="line">			  &#123;</span><br><span class="line">				  return listall; //因为至少要包括两个数，要求的是正整数序列，那么最小的和为3  </span><br><span class="line">			  &#125;</span><br><span class="line">	  int small = 1;//用来记录正整数序列中最小的数，</span><br><span class="line">	  int big = 2;//用来记录正整数序列中最大的数</span><br><span class="line">	  int mid = (sum + 1)/2;//序列之和为sum的数至少包括两个数，所以small&lt;mid</span><br><span class="line">	  int cursum = small + big;//当前序列总和</span><br><span class="line">	  while(small &lt; mid)</span><br><span class="line">	  &#123;  </span><br><span class="line">		  //当前的序列和大于sum</span><br><span class="line">			  while(cursum &gt; sum &amp;&amp; small &lt; mid)</span><br><span class="line">			  &#123;</span><br><span class="line">				  cursum = cursum-small;</span><br><span class="line">				  small++;</span><br><span class="line">			  &#125;</span><br><span class="line">			  //当前序列和为sum了，则将这些数加入到list中</span><br><span class="line">			  if(cursum == sum)</span><br><span class="line">			  &#123;</span><br><span class="line">				  ArrayList&lt;Integer&gt; listsum = new ArrayList&lt;Integer&gt;();</span><br><span class="line">				  add(listsum,small,big);</span><br><span class="line">				  listall.add(listsum);</span><br><span class="line">				</span><br><span class="line">			  &#125;</span><br><span class="line">		  //当前的序列和小于sum</span><br><span class="line">			  big++;</span><br><span class="line">			  cursum = cursum+big;</span><br><span class="line">		  </span><br><span class="line">	  &#125;</span><br><span class="line">	  return listall;</span><br><span class="line">				 </span><br><span class="line">    &#125;</span><br><span class="line"> private static void add(ArrayList&lt;Integer&gt; list,int small,int big)</span><br><span class="line"> &#123;</span><br><span class="line">	 for (int i = small; i &lt;= big; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		list.add(i);</span><br><span class="line">	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h3><p>描述：输入一个人链表的头结点，从尾到头打印链表的每个值<br>思路：利用栈，从头结点开始依次将节点压入栈中，再将栈中的节点依次弹出来；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//利用递归</span><br><span class="line">private void print(ListNode  head)&#123;</span><br><span class="line">	if(head!=null)&#123;</span><br><span class="line">		if(head.next!=null)</span><br><span class="line">			print(head.next);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(head.val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="那些关于二叉树的事儿"><a href="#那些关于二叉树的事儿" class="headerlink" title="那些关于二叉树的事儿"></a>那些关于二叉树的事儿</h2><p>二叉树： 每个节点最多只有两个子节点；<br>二叉搜索树：左节点小于右节点，中序遍历的结果是一个递增序列；<br>完全二叉树: 只有最下面两层的节点的度可以小于2，并且最下一层的叶子节点集中在靠左的位置；<br>前序遍历：根，左，右<br>中序遍历：左，根，右<br>后序遍历：左，右，根<br>宽度优先遍历：从第一层节点开始一层一层访问，同一层中从左到右依次访问<br>红黑树：<br>堆（最大堆和最小堆）：一个大小为n的堆是一个含有n个节点的完全二叉树，如果树中节点的值大于或等于父节点的值，则为最小堆，即最小堆的根节点（堆顶）是最小的；</p>
<h3 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h3><p>描述：输入某二叉树的前序遍历和中序遍历结果，要求重建该二叉树；<br><img src="/2018/08/26/剑指offer笔记/重建的二叉树.jpg"><br><img src="/2018/08/26/剑指offer笔记/分析.jpg"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode &#123;</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(int x) &#123;</span><br><span class="line">            this.val = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">     * 给定二叉树的前序遍历和中序遍历，重构二叉树。假设前序遍历和中序遍历都没有重复的数</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param pre  前序遍历</span><br><span class="line">     * @param in    中序遍历</span><br><span class="line">     * @return        二叉树根节点</span><br><span class="line">     */</span><br><span class="line">    public TreeNode reConstructBinaryTree(int[] pre,int[] in) &#123;</span><br><span class="line">        /*</span><br><span class="line">         * 输入合法性判断， 不能为空，先序和后序长度要一致</span><br><span class="line">         */</span><br><span class="line">        if(pre == null || in == null || pre.length != in.length)</span><br><span class="line">            return null;</span><br><span class="line"></span><br><span class="line">        return construct(pre, 0, pre.length-1, in, 0, in.length-1);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param pre    前序遍历</span><br><span class="line">     * @param ps    前序遍历的开始位置</span><br><span class="line">     * @param pe    前序遍历的结束位置</span><br><span class="line">     * @param in    中序遍历</span><br><span class="line">     * @param is    中序遍历的开始位置</span><br><span class="line">     * @param ie    中序遍历的结束位置</span><br><span class="line">     * @return        数的根节点</span><br><span class="line">     */</span><br><span class="line">    private TreeNode construct(int[] pre, int ps, int pe, int[] in, int is, int ie) &#123;</span><br><span class="line">        if(ps &gt; pe) return null;</span><br><span class="line"></span><br><span class="line">        // 取前序遍历的第一个数字就是根节点</span><br><span class="line">        int value = pre[ps];</span><br><span class="line">        // 在中序遍历中中寻找根节点</span><br><span class="line">        int index =is;</span><br><span class="line">        while(index &lt;= ie &amp;&amp; value != in[index]) &#123;</span><br><span class="line">            index ++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果在整个中序遍历的数组中没有找到，说明输入的参数是不合法的，抛出异常</span><br><span class="line">        if(index &gt; ie)</span><br><span class="line">            throw new RuntimeException(&quot;Invalid Iuput!&quot;);</span><br><span class="line"></span><br><span class="line">        // 创建当前根节点，并为根节点赋值</span><br><span class="line">        TreeNode node = new TreeNode(value);</span><br><span class="line">        // 递归调用构建当前节点的左子树</span><br><span class="line"></span><br><span class="line">        node.left = construct(pre, ps+1, ps+index-is, in, is, index-1);</span><br><span class="line">        // 递归调用构建当前节点的右子树</span><br><span class="line">        node.right = construct(pre, ps+index-is+1, pe, in, index+1, ie);</span><br><span class="line"></span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private void printTree(TreeNode root) &#123;</span><br><span class="line">        if(root != null) &#123;</span><br><span class="line">            printTree(root.left);</span><br><span class="line">            System.out.print(root.val + &quot; &quot;);</span><br><span class="line">            printTree(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="二叉树的下一个节点"><a href="#二叉树的下一个节点" class="headerlink" title="二叉树的下一个节点"></a>二叉树的下一个节点</h3><p>描述：给定一棵二叉树和其中的一个节点，要求按照中序遍历的顺序输出该节点的下一个节点；树中的结点不仅包含左右子结点，同时包含指向父结点的指针。<br>思路：</p>
<ul>
<li>如果该节点有右子树，那中序遍历的下一个节点就是它的右子树的最左节点</li>
<li>如果该节点没有右子树，则找第一个当前节点是父节点左孩子的节点<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">			</span><br><span class="line">class TreeLinkNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeLinkNode left = null;</span><br><span class="line">    TreeLinkNode right = null;</span><br><span class="line">    TreeLinkNode parent = null;</span><br><span class="line">    </span><br><span class="line">    TreeLinkNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeLinkNode(int val,TreeLinkNode parent) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">        this.parent=parent;</span><br><span class="line">    &#125;</span><br><span class="line">    public void set(TreeLinkNode left,TreeLinkNode right)&#123;</span><br><span class="line">        this.left=left;</span><br><span class="line">        this.right=right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class Problem8 &#123;</span><br><span class="line">    public static TreeLinkNode GetNext(TreeLinkNode node) &#123;</span><br><span class="line">        if(node==null) return null;</span><br><span class="line">        if(node.right!=null)&#123;    //如果有右子树，则找右子树的最左节点</span><br><span class="line">            node = node.right;</span><br><span class="line">            while(node.left!=null) node = node.left;</span><br><span class="line">            System.out.print(node.val);</span><br><span class="line">            return node;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            while(node.parent!=null)&#123; //没右子树，则找第一个当前节点是父节点左孩子的节点</span><br><span class="line">                if(node.parent.left==node) &#123;</span><br><span class="line">                    System.out.print(node.parent.val);</span><br><span class="line">                    return node.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="有序二叉树中，求两个节点的最低公共祖先"><a href="#有序二叉树中，求两个节点的最低公共祖先" class="headerlink" title="有序二叉树中，求两个节点的最低公共祖先"></a>有序二叉树中，求两个节点的最低公共祖先</h3><p>思路：从根节点出发遍历树，如果当前节点比两个节点的值大，则下一步遍历当前节点的左子树，反之则遍历当前节点的右子树；直到当前节点的值处于这两个节点值的中间为止，此时当前节点就是所求； </p>
<h3 id="二叉搜索树的从小到大的第k个节点"><a href="#二叉搜索树的从小到大的第k个节点" class="headerlink" title="二叉搜索树的从小到大的第k个节点"></a>二叉搜索树的从小到大的第k个节点</h3><p>思路：中序遍历该树即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static ArrayList&lt;TreeNode&gt; arr = new ArrayList&lt;TreeNode&gt;();</span><br><span class="line">   private static TreeNode getKNode(TreeNode root,int k)&#123;</span><br><span class="line">      if(root==null||k==0) return null;</span><br><span class="line">      inOrder(root);</span><br><span class="line">      TreeNode result=root;</span><br><span class="line">      if(k&lt;=arr.size())&#123;</span><br><span class="line">          result = arr.get(k-1);</span><br><span class="line">      &#125;else &#123;</span><br><span class="line">          return null;</span><br><span class="line">      &#125;</span><br><span class="line">      return result;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   private static void inOrder(TreeNode root)&#123;</span><br><span class="line">       if(root==null) return;</span><br><span class="line">       if(root.left!=null)</span><br><span class="line">           inOrder(root.left);</span><br><span class="line">       arr.add(root);</span><br><span class="line">       if(root.right!=null)&#123;</span><br><span class="line">           inOrder(root.right);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static int getDept(TreeNode root)&#123;</span><br><span class="line">        if(root==null) return 0;</span><br><span class="line">        int l=getDept(root.left)+1;</span><br><span class="line">        int r=getDept(root.right)+1;</span><br><span class="line">        return (l&gt;r)?l:r;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断某棵树是否是平衡二叉树"><a href="#判断某棵树是否是平衡二叉树" class="headerlink" title="判断某棵树是否是平衡二叉树"></a>判断某棵树是否是平衡二叉树</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static boolean isBalanceTree(TreeNode root)&#123;</span><br><span class="line">    if(root==null)</span><br><span class="line">        return true;</span><br><span class="line">    int l=getDept(root.left);</span><br><span class="line">    int r=getDept(root.right);</span><br><span class="line">    if(l-r&gt;1||r-l&gt;1)</span><br><span class="line">        return false;</span><br><span class="line">    return isBalanceTree(root.left)&amp;&amp;isBalanceTree(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h3><p><a href="https://blog.csdn.net/d12345678a/article/details/54178612" target="_blank" rel="noopener">https://blog.csdn.net/d12345678a/article/details/54178612</a></p>
<ul>
<li>序列化：根据前序遍历的顺序，遍历二叉树絮遇到的空左子树或者右子树时，用”#”替代；节点间用”,”分隔开；</li>
<li>反序列化：输入序列化的得到的字符串，还原二叉树；</li>
</ul>
<h2 id="递归思想与回溯法"><a href="#递归思想与回溯法" class="headerlink" title="递归思想与回溯法"></a>递归思想与回溯法</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h4 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h4><h5 id="不好的方法（递归）"><a href="#不好的方法（递归）" class="headerlink" title="不好的方法（递归）"></a>不好的方法（递归）</h5><p>此方法重复求了很多节点，时间复杂度大<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static int Fibonacci(int n)&#123;</span><br><span class="line">	if(n&lt;=0) return 0;</span><br><span class="line">	if(n==1) return 1; </span><br><span class="line">	return  Fibonacci(n-1)+ Fibonacci(n-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="利用循环实现"><a href="#利用循环实现" class="headerlink" title="利用循环实现"></a>利用循环实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private static int Fibonacci(int n)&#123;</span><br><span class="line">	int[] result=&#123;0,1&#125;//保存n=0,1的值</span><br><span class="line">	if(n&lt;2) return result[n];</span><br><span class="line">	int f0=0;</span><br><span class="line">	int f1=1;</span><br><span class="line">	int fn=0;</span><br><span class="line">	for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">       fn=f0+f1;</span><br><span class="line">       f0=f1;</span><br><span class="line">       f1=fn;</span><br><span class="line">    &#125;</span><br><span class="line">    return fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="斐波那契数列的应用"><a href="#斐波那契数列的应用" class="headerlink" title="斐波那契数列的应用"></a>斐波那契数列的应用</h5><p>描述：一只青蛙一次可以跳上1级台阶，也可以跳上两节台阶，求该青蛙跳上n级台阶一共有多少中跳法；<br>思路：如果只有1级台阶，那只有f(1)=1种跳法；如果有2级台阶，就有f(2)=2种跳法；<br>当有n级台阶时，青蛙第一次跳的选择有两种：一是第一次只跳1级，此时的跳法数等于后面n-1级台阶的跳法数；二是第一次跳2级，此时的跳法数等于后面n-2级台阶的跳法数；所以f(n)=f(n-1)+f(n-2);</p>
<p>类似的题目还有很多，可以用数学归纳法进行总结；</p>
<h4 id="字符串的全排列"><a href="#字符串的全排列" class="headerlink" title="字符串的全排列"></a>字符串的全排列</h4><p>问题描述：输入一个字符串，打印出该字符串的所有排列。例如，输入字符串”abc”，则输出有字符’a’,’b’,’c’所能排列出来的所有字符串”abc”,”acb”,”bac”,”bca”,”cab”,”cba”；</p>
<p>递归实现:将字符串看成两部分，第一部分是第一个字符，另一部分是之后的所有字符，之后将第一部分的字符与第二部分的字符逐个交换位置；</p>
<p>代码：<a href="https://www.cnblogs.com/liuzhen1995/p/6395361.html" target="_blank" rel="noopener">https://www.cnblogs.com/liuzhen1995/p/6395361.html</a></p>
<h4 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h4><p>问题描述：在8X8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。</p>
<p>思路：初始化一个数组array{0,1,2,3,4,5,6,7,}，对这个字符串进行全排列，array[i]表示在第i行第array[i]列上有一个皇后，因为i是唯一的，所以这个皇后一定不是在同一行上也不在同一列上，所以只需判断皇后是否在同一对角线上就可以了；<br>即判断是否有array[i]-array[j]==i-j 或者 array[i]-array[j]=j-i;<br><a href="https://blog.csdn.net/zhong317/article/details/4586131" target="_blank" rel="noopener">https://blog.csdn.net/zhong317/article/details/4586131</a></p>
<h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><p>在包含问题的所有可能解空间中，从根节点处罚，按照深度优先策略进行搜索，对于解空间树的某个节点，如果该节点满足问题的约束条件，则进入该子树继续进行搜索，否则将以该节点为根节点进行剪枝。回溯法常常可以避免搜索所有可能解，适用于组合较数较大的问题。</p>
<h4 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h4><p>描述：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。<br>例如<br>a b c e<br>s f c s<br>a d e e<br>{ a b c e s f c s a d e e }矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
<p>思路：首先，在矩阵中任选一个格子作为路径的起点。假设矩阵中某个格子的字符为ch，并且这个格子将对应于在路径上的第i个字符。假设路径上的第i个字符不是ch。那么这个格子不可能处在路径上的第i个位置。假设路径上的第i个字符正好是ch。那么往相邻的格子寻找路径上的第i+1个字符。除在矩阵边界上的格子之外，其它格子都有4个相邻的格子。反复这个过程知道路径上的全部字符都在矩阵中找到相应的位置。</p>
<p>　　因为回朔法的递归特性，路径能够被开成一个栈。当在矩阵中定位了路径中前n个字符的位置之后。在与第n个字符相应的格子的周围都没有找到第n+1个字符。这个时候仅仅要在路径上回到第n-1个字符。又一次定位第n个字符。</p>
<p>　　因为路径不能反复进入矩阵的格子。还须要定义和字符矩阵大小一样的布尔值矩阵，用来标识路径是否已经进入每个格子。 　　<br>    当矩阵中坐标为（row,col）的格子和路径字符串中下标为pathLength的字符一样时。从4个相邻的格子(row,col-1),(row-1,col),(row,col+1)以及(row+1,col)中去定位路径字符串中下标为pathLength+1的字符。</p>
<p>　　假设4个相邻的格子都没有匹配字符串中下标为pathLength+1的字符，表明当前路径字符串中下标为pathLength的字符在矩阵中的定位不对，我们须要回到前一个字符(pathLength-1)，然后又一次定位。<br>　　一直反复这个过程，直到路径字符串上全部字符都在矩阵中找到合适的位置；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static boolean hasPath(char[] matrix, int rows, int cols, char[] str) &#123;</span><br><span class="line">        boolean flag[] = new boolean[matrix.length];</span><br><span class="line">        for (int i = 0; i &lt; rows; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; cols; j++) &#123;</span><br><span class="line">                if (helper(matrix, rows, cols, i, j, str, 0, flag))</span><br><span class="line">                    return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">/*</span><br><span class="line">k 记录str中的字符的位置</span><br><span class="line"> */</span><br><span class="line">    private static boolean helper(char[] matrix, int rows, int cols, int i, int j, char[] str, int k, boolean[] flag) &#123;</span><br><span class="line">        int index = i * cols + j;</span><br><span class="line">        if (i &lt; 0 || i &gt;= rows || j &lt; 0 || j &gt;= cols || matrix[index] != str[k] || flag[index])</span><br><span class="line">            return false;</span><br><span class="line">        if(k == str.length - 1) return true;</span><br><span class="line">        flag[index] = true;</span><br><span class="line">        if (       helper(matrix, rows, cols, i - 1, j, str, k + 1, flag)</span><br><span class="line">                || helper(matrix, rows, cols, i + 1, j, str, k + 1, flag)</span><br><span class="line">                || helper(matrix, rows, cols, i, j - 1, str, k + 1, flag)</span><br><span class="line">                || helper(matrix, rows, cols, i, j + 1, str, k + 1, flag)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        flag[index] = false;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h4><p>描述：地上有个m行n列的方格。一个机器人从坐标(0,0)的格子开始移动，它每一次可以向左、右、上、下移动一格，但不能进入行坐标和列坐标的数位之和大于k的格子。<br>例如我们输入的K=4，则机器人能够到达的格子数为：15。<br><img src="/2018/08/26/剑指offer笔记/机器人路径.jpg"><br>思路：机器人从 [0,0] 格子开始移动，当它移动到下一个格子的时候，我们通过格子的数位来判断该机器人是否有权利进入，如果可以，格子数+1，我们再判断[i-1,j],[i,j-1][i+1,j],[i,j+1]这相邻的四个格子能否进入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private  static int movingCount(int threshold,int rows,int cols)&#123;</span><br><span class="line">        if(threshold&lt;0||rows&lt;0||cols&lt;0)</span><br><span class="line">            return 0;</span><br><span class="line">        boolean[] visited=new boolean[rows * cols];</span><br><span class="line">        int count = movingCountCore(threshold, rows, cols, 0, 0, visited);</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">    private  static int movingCountCore(int threshold,int rows,int cols,int row,int col,boolean[] visited)&#123;</span><br><span class="line">        int count= 0;</span><br><span class="line">        if(check(threshold, rows, cols, row, col, visited))&#123;</span><br><span class="line"></span><br><span class="line">            visited[row*cols+col]=true;</span><br><span class="line">            count=1 + movingCountCore(threshold, rows, cols, row + 1, col, visited)</span><br><span class="line">                    + movingCountCore(threshold, rows, cols, row - 1, col, visited)</span><br><span class="line">                    + movingCountCore(threshold, rows, cols, row, col + 1, visited)</span><br><span class="line">                    + movingCountCore(threshold, rows, cols, row, col - 1, visited);</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">    private static boolean check(int threshold, int rows, int cols, int row, int col, boolean[] visited)&#123;</span><br><span class="line">        if (row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; cols &amp;&amp; visited[row * cols + col] == false</span><br><span class="line">                &amp;&amp; getDigitSum(col) + getDigitSum(row) &lt;= threshold)</span><br><span class="line">            return true;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    private static int getDigitSum(int col) &#123;</span><br><span class="line">        int sum=0;</span><br><span class="line">        while(col!=0)&#123;</span><br><span class="line">            sum+=col%10;</span><br><span class="line">            col=col/10;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="回溯法求解图的着色问题"><a href="#回溯法求解图的着色问题" class="headerlink" title="回溯法求解图的着色问题"></a>回溯法求解图的着色问题</h4><p><a href="https://blog.csdn.net/lican19911221/article/details/26264471" target="_blank" rel="noopener">https://blog.csdn.net/lican19911221/article/details/26264471</a></p>
<h2 id="Java-栈与队列"><a href="#Java-栈与队列" class="headerlink" title="Java 栈与队列"></a>Java 栈与队列</h2><p>资料：<a href="https://blog.csdn.net/ls5718/article/details/51700503" target="_blank" rel="noopener">https://blog.csdn.net/ls5718/article/details/51700503</a></p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>特点：先进后出</p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>特点：先进先出</p>
<p>队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作。<br>LinkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用。</p>
<ul>
<li>offer(); 添加元素</li>
<li>poll(); 返回第一个元素，并在队列中删除</li>
<li>element(): 返回第一个元素 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.Queue;</span><br><span class="line"> </span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //add()和remove()方法在失败的时候会抛出异常(不推荐)</span><br><span class="line">        Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;();</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="关于栈和队列的题目"><a href="#关于栈和队列的题目" class="headerlink" title="关于栈和队列的题目"></a>关于栈和队列的题目</h3><h4 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h4><p>思路：<br>压入元素直接压入stack1，删除元素先查看stack2是否为空,在stack2中的栈顶元素是最先进入stack1的元素，非空则弹出；空则将stack1中元素取出，置于stack2中；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Problem9 &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    public void push(int node)&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int pop()&#123;</span><br><span class="line"></span><br><span class="line">        if(stack2.empty())&#123;</span><br><span class="line">            while(!stack1.empty())</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h4><p>描述：定义栈的数据结构，在该类型中实现一个能找到栈的最小值的min函数；在栈中，调用min，push，pop的时间复杂度都是O(1)；<br>思路：建立一个辅助栈，每次在主栈中压入一个元素时，就判断该数与辅助栈的栈顶元素比较，如果小于栈顶元素，就把该数压进辅助栈，反之则将辅助栈的栈顶元素再压进去辅助栈里；<br><img src="/2018/08/26/剑指offer笔记/1.png" title="状态图"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class StackWithMin &#123;</span><br><span class="line">        Stack&lt;Integer&gt; main = new Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; help = new Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        public void stackWithMinPush(int item) &#123;</span><br><span class="line">            main.push(item);</span><br><span class="line">            if (help.size() &gt; 0 || item &lt; help.peek()) &#123;</span><br><span class="line">                help.push(item);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                help.push(help.peek());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //main栈和min栈弹出元素</span><br><span class="line">        public void stackWithMinPop() &#123;</span><br><span class="line">            if (main.size() &gt; 0 &amp;&amp; help.size() &gt; 0) &#123;</span><br><span class="line">                main.pop();</span><br><span class="line">                help.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //main栈的栈顶元素</span><br><span class="line">        public int stackWithDataPeep() &#123;</span><br><span class="line">            if (main.size() &gt; 0) &#123;</span><br><span class="line">                return main.peek();</span><br><span class="line">            &#125;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //min栈的栈顶元素，栈顶元素为main栈中现有元素的最小元素</span><br><span class="line">        public int stackWithMinMin() &#123;</span><br><span class="line">            if (main.size() &gt; 0 &amp;&amp; help.size() &gt; 0) &#123;</span><br><span class="line">                return help.peek();</span><br><span class="line">            &#125;</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h4><p>描述：给定一个数组和滑动窗口的大小，找出所有滑动窗口的最大值；<br>例如，如果输入数组{2,3,4,2,6,2,5,1} 及滑动窗口的大小3，那么一共存在6个滑动窗口：{[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}，他们的最大值分别为{4,4,6,6,6,5}。</p>
<p>思路：</p>
<h2 id="动态规划与贪婪算法"><a href="#动态规划与贪婪算法" class="headerlink" title="动态规划与贪婪算法"></a>动态规划与贪婪算法</h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p> 应用于：大问题能分解为小问题，每个小问题也存在最优解，把小问题的最优解组合起来就是这个问题的最优解；</p>
<h3 id="贪婪算法"><a href="#贪婪算法" class="headerlink" title="贪婪算法"></a>贪婪算法</h3><p>应用于： 大问题分解为小问题，对于每一个小问题存在很多种解（很难求出最优解），此时我们选择一个相对好的解（基于某种贪婪策略），之后基于这个解而确定问题的最优解；</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>剑指Offer（第二版）面试题14：剪绳子<br><a href="https://blog.csdn.net/Koala_Tree/article/details/78932316" target="_blank" rel="noopener">https://blog.csdn.net/Koala_Tree/article/details/78932316</a></p>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>在实际编程中位移运算比除法运算更加快速<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;      :     左移运算符，num &lt;&lt; 1,相当于num乘以2</span><br><span class="line">&gt;&gt;      :     右移运算符，num &gt;&gt; 1,相当于num除以2</span><br><span class="line">&gt;&gt;&gt;     :     无符号右移，忽略符号位，空位都以0补齐</span><br><span class="line">&amp;(按位与)：    只有两个操作数对应位同为1时，结果为1，否则为0.</span><br><span class="line">|(按位或):	    只有两个操作数对应位同为0时，结果为0，否则为1.</span><br><span class="line">~(按位非):		取反；</span><br><span class="line">^(异或)  :  只有两个数不相同时为1，否则为0；(用于二进制的加法)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> 1010      十进制：10     原始数         number</span><br><span class="line">10100      十进制：20     左移一位       number = number &lt;&lt; 1;</span><br><span class="line"> 1010      十进制：10     右移一位       number = number &gt;&gt; 1;</span><br></pre></td></tr></table></figure>
<p>Java位运算原理及使用讲解：<a href="https://blog.csdn.net/goskalrie/article/details/52796360" target="_blank" rel="noopener">https://blog.csdn.net/goskalrie/article/details/52796360</a></p>
<h3 id="输入一个整数求其二进制数中的1的个数"><a href="#输入一个整数求其二进制数中的1的个数" class="headerlink" title="输入一个整数求其二进制数中的1的个数"></a>输入一个整数求其二进制数中的1的个数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">得到的结论是：把一个整数减去<span class="number">1</span>，再和原整数做位与运算，会把该整数最右边的<span class="number">1</span>变为<span class="number">0</span>；</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Java使用补码来表示二进制数</span><br><span class="line">对正数来说 ,补码就是其二进制数。</span><br><span class="line">对 负 数 而 言 ,把该 数 绝 对 值 的 补 码 按 位 取 反 ,然后 对 整 个数 加 <span class="number">1</span>,即得 该 数的 补 码 。 如 -<span class="number">1</span>的补 码 为<span class="number">11111111111111111111111111111111</span>(<span class="number">00000000000000000000000000000001</span></span><br><span class="line">按 位 取 反 <span class="number">11111111111111111111111111111110</span>+<span class="number">1</span>=<span class="number">11111111111111111111111111111111</span> )。</span><br></pre></td></tr></table></figure>
<h2 id="翻转字符串"><a href="#翻转字符串" class="headerlink" title="翻转字符串"></a>翻转字符串</h2><h3 id="翻转单词顺序"><a href="#翻转单词顺序" class="headerlink" title="翻转单词顺序"></a>翻转单词顺序</h3><p>描述：输入一个英文句子，翻转句子中单词的顺序，但单词内字符串的顺序不变。例如输入字符串：“I am a student.”,则输出“student. a am I”.</p>
<p>思路：<br>第一步先将整个句子逆时针旋转180度得到：.tneduts a ma I<br>第二步在将句子中的单词逐个逆时针旋转180度得到：student. a am I</p>
<p>代码：</p>
<h4 id="方法1：使用String的split函数，将句子先分为几个单词，之后只需调换单词的顺序即可；"><a href="#方法1：使用String的split函数，将句子先分为几个单词，之后只需调换单词的顺序即可；" class="headerlink" title="方法1：使用String的split函数，将句子先分为几个单词，之后只需调换单词的顺序即可；"></a>方法1：使用String的split函数，将句子先分为几个单词，之后只需调换单词的顺序即可；</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static String ReverseSentence1(String str) &#123;</span><br><span class="line">        String trim = str.trim();</span><br><span class="line">        String a = &quot;&quot;;</span><br><span class="line">        if(&quot;&quot;.equals(str.trim()))&#123;</span><br><span class="line">            return str;</span><br><span class="line">        &#125;</span><br><span class="line">        //将字符串通过split函数将其分开，并用数组接收</span><br><span class="line">        String[] split = str.split(&quot; &quot;);</span><br><span class="line">        //反向拼接并用空格连接</span><br><span class="line">        //split:&#123;&quot;I&quot;,&quot;am&quot;,&quot;a&quot;,&quot;student.&quot;&#125;</span><br><span class="line">        for (int i = split.length-1; i &gt;=0; i--) &#123;</span><br><span class="line">            a += split[i]+&quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return a.trim();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static String ReverSentence2(String str) &#123;</span><br><span class="line">        return (str.lastIndexOf(&quot; &quot;)==-1)?str:str.substring(str.lastIndexOf(&quot; &quot;)+1) +&quot; &quot;+ReverSentence2(str.substring(0,str.lastIndexOf(&quot; &quot;)));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法3："><a href="#方法3：" class="headerlink" title="方法3："></a>方法3：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/*****反转单个字符串函数****/</span><br><span class="line">    public char[] reverseStr(char[] StrArr, int start, int end)</span><br><span class="line">    &#123;</span><br><span class="line">        if (StrArr == null)</span><br><span class="line">            return null;</span><br><span class="line"></span><br><span class="line">        while(start &lt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            char temp = StrArr[start];</span><br><span class="line">            StrArr[start ++] = StrArr[end];</span><br><span class="line">            StrArr[end --]   = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return StrArr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** 根据单词进行反转</span><br><span class="line">     *  策略是先反转整个字符串，在根据空格划分单词，然后依次反转每个单词*/</span><br><span class="line">    public String ReverSentence3(String dataStr)</span><br><span class="line">    &#123;</span><br><span class="line">        if(dataStr == null || dataStr.length() == 0)</span><br><span class="line">            return dataStr;</span><br><span class="line">        char[] dataArr = dataStr.toCharArray();</span><br><span class="line">        //反转整个字符串</span><br><span class="line">        int start = 0;</span><br><span class="line">        int end = dataStr.length() - 1;</span><br><span class="line">        reverseStr(dataArr, start, end);</span><br><span class="line">        //类似于双指针法，根据空格划分单词</span><br><span class="line">        start = end = 0;</span><br><span class="line">        while(start &lt; dataStr.length())</span><br><span class="line">        &#123;</span><br><span class="line">            //如果start为空格，则跳过它不把它识别为单词的一部分</span><br><span class="line">            if(dataArr[start] == &apos; &apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                start ++;</span><br><span class="line">                end ++;</span><br><span class="line">            &#125;</span><br><span class="line">            //当end指针移到字符串数组末尾，或者当前为空格，则start指针到end指针之间构成一个单词</span><br><span class="line">            else if(end == dataStr.length() || dataArr[end] == &apos; &apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                //注意end已经对应单词末尾后面一位，要注意先自减</span><br><span class="line">                reverseStr(dataArr, start, --end);</span><br><span class="line">                //开始识别下一个单词</span><br><span class="line">                start = ++ end;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                //此为一般情况，end指针一直后移</span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new String(dataArr);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h3><p>描述：输入一个字符串和一个整数n，将这个字符串的前n个字符转移到字符串的后面<br>例如：<br>input：abcdefg 2<br>output:  cdefgab</p>
<p>思路：将字符串分为两部分{ab},{cdefg},之后对这两部分做翻转得到{ba},{gfedc},再将这两部分合并{bagfedc}，之后再对这个字符串进行翻转 得到{cdefgab}；</p>
<p>代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static String ReverseSentence(String str,int n)&#123;</span><br><span class="line">        char[] ch1=reverseStr(str.substring(0,n).toCharArray(),0,str.substring(0,n).length()-1);</span><br><span class="line">        System.out.println(ch1);</span><br><span class="line">        char[] ch2=reverseStr(str.substring(n,str.length()).toCharArray(),0,str.substring(n,str.length()).length()-1);</span><br><span class="line">        System.out.println(ch2);</span><br><span class="line">        char[]chars=(new String(ch1)+new String(ch2)).toCharArray();</span><br><span class="line">        return new String(reverseStr(chars,0,chars.length-1));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="抽象建模"><a href="#抽象建模" class="headerlink" title="抽象建模"></a>抽象建模</h2><h3 id="扑克牌中的顺子"><a href="#扑克牌中的顺子" class="headerlink" title="扑克牌中的顺子"></a>扑克牌中的顺子</h3><p>描述: 从扑克牌中随机抽 5 张牌,判断是不是顺子,即这 5 张牌是不是连续的。2-10 为数字本身, A为1, J为1, Q为12,K为13, 而大小王可以看成任意的数字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Problem61 &#123;</span><br><span class="line">    private static boolean solution(int [] a)&#123;</span><br><span class="line">        if(a.length&lt;5||a==null) return false;</span><br><span class="line">        Arrays.sort(a);</span><br><span class="line">        int numberOfZero=0;</span><br><span class="line">        int numberOfGap=0;</span><br><span class="line">        for(int i=0;i&lt;a.length;i++)&#123;</span><br><span class="line">            if(a[i]==0) numberOfZero++;</span><br><span class="line">        &#125;</span><br><span class="line">        //比如有&#123;0,0,7,11,9&#125;，则从7开始计算，9和7相差9-7-1=1张牌</span><br><span class="line">        for(int i=numberOfZero;i&lt;4;i++)&#123;</span><br><span class="line">            if(a[i+1]-a[i]==0)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            numberOfGap+=a[i+1]-a[i]-1;</span><br><span class="line">        &#125;</span><br><span class="line">        return (numberOfGap&gt;numberOfZero)?false:true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a[]=&#123;0,0,7,11,9&#125;;</span><br><span class="line">        System.out.println(solution(a));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="约瑟夫环问题"><a href="#约瑟夫环问题" class="headerlink" title="约瑟夫环问题"></a>约瑟夫环问题</h3><p>描述：0，1，，，，，n-1这n 个数字排成一个圆圈，从数字0开始每次从这个圆圈中删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p>
<p>思路1：创建一个共有n个结点的环形链表，然后每次都从这个链表中删除第m个结点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public static int lastRemaining(int n, int m) &#123;</span><br><span class="line">        if (n &lt; 1 || m &lt; 1) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = new LinkedList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        // 要删除元素的位置</span><br><span class="line">        int idx = 0;</span><br><span class="line">        // 开始计数的位置</span><br><span class="line">        int start = 0;</span><br><span class="line">        while (list.size() &gt; 1) &#123;</span><br><span class="line">            // 只要移动m-1次就可以移动到下一个要删除的元素上</span><br><span class="line">            for (int i = 1; i &lt; m; i++) &#123;</span><br><span class="line">                idx = (idx + 1) % list.size(); // 【A】</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            list.remove(idx);</span><br><span class="line"></span><br><span class="line">            // 确保idx指向每一轮的第一个位置</span><br><span class="line">            // 下面的可以不用，【A】已经可以保证其正确性了，可以分析n=6，m=6的第一次删除情况</span><br><span class="line">            //  if (idx == list.size()) &#123;</span><br><span class="line">            //      idx = 0;</span><br><span class="line">            //  &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return list.get(0);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="求1-2-···-n"><a href="#求1-2-···-n" class="headerlink" title="求1+2+···+n;"></a>求1+2+···+n;</h3><p>要求： 不用乘除、for、while、if、else、switch、case、A?B:C<br>递归：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static int plus(int sum,int n)&#123;</span><br><span class="line">		boolean is_end=true;</span><br><span class="line">		sum+=n;</span><br><span class="line">		is_end=(n&gt;0) &amp;&amp; ((sum=plus(sum,--n))&gt;0);</span><br><span class="line">		return sum;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="不用-做加法运算"><a href="#不用-做加法运算" class="headerlink" title="不用+ - * /做加法运算"></a>不用+ - * /做加法运算</h3><p>思路：位运算的异或实现<br>假设我们这来那个数分别为12和9，对应的二进制为：1100和1001，实现分三步走<br>1、首先只做加法，不考虑进位问题。结果为0101。相当于做异或运算，(1100^1001)=0101；<br>2、接着只考虑进位。只有1+1会发生进位，所以相当于做按位与运算， 得到结果：(1100&amp;1001)=1000；<br>3、在二进制中，1+1会发生进位。所以对于第二步的结果应该采用左移1位 1000&lt;&lt; = 10000</p>
<p>重复上面的步骤，对0101和10000进行加法运算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private static int add(int num1,int num2)&#123;</span><br><span class="line">       int sum,carry;</span><br><span class="line">       do&#123;</span><br><span class="line">           sum=num1^num2;</span><br><span class="line">           carry=(num1&amp;num2)&lt;&lt;1;</span><br><span class="line">           num1=sum;</span><br><span class="line">           num2=carry;</span><br><span class="line">       &#125;while(num2!=0);</span><br><span class="line">       return num1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="不使用中间变量交换两个变量的值"><a href="#不使用中间变量交换两个变量的值" class="headerlink" title="不使用中间变量交换两个变量的值"></a>不使用中间变量交换两个变量的值</h3><h4 id="基于加减法"><a href="#基于加减法" class="headerlink" title="基于加减法"></a>基于加减法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=a+b;</span><br><span class="line">b=a-b;</span><br><span class="line">a=a-b;</span><br><span class="line">``` </span><br><span class="line">#### 基于异或运算</span><br></pre></td></tr></table></figure>
<p>a=a^b;<br>b=a^b;<br>b=a^b;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">## Singleton模式的实现</span><br><span class="line">所谓Singleton就是设计一个类，我们只能生成该类的一个实例；即单例模式</span><br></pre></td></tr></table></figure></p>
<p>public class Singleton {<br>    private static Singleton instance=new Singleton();<br>    private Singleton(){</p>
<pre><code>}
public static Singleton getInstance(){
    return instance;
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定义一个私有的内部类，在第一次用这个嵌套类时，会创建一个实例。而类型为SingletonHolder的类，只有在Singleton.getInstance()中调用，由于私有的属性，他人无法使用SingleHolder，不调用Singleton.getInstance()就不会创建实例。</span><br></pre></td></tr></table></figure></p>
<p>public class Singleton {<br>    private Singleton(){</p>
<pre><code>}
private static class SingletonHolder{
    private final static Singleton instance=new Singleton();
}
public static Singleton getInstance(){
    return SingletonHolder.instance;
}
</code></pre><p>}<br><code>`</code></p>

      
    </div>
    
    
    
    
    <div>
      
        
<div class="my_post_copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>
  
  <!-- JS库 sweetalert 可修改路径 -->
  <script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script>
  <script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>
  <p><span>本文标题:</span><a href="/2018/08/26/剑指offer笔记/">剑指offer笔记</a></p>
  <p><span>文章作者:</span><a href="/" title="访问 KingSoul 的个人博客">KingSoul</a></p>
  <p><span>发布时间:</span>2018年08月26日 - 18:08</p>
  <p><span>最后更新:</span>2018年09月05日 - 11:09</p>
  <p><span>原始链接:</span><a href="/2018/08/26/剑指offer笔记/" title="剑指offer笔记">ztzhang.cn/2018/08/26/剑指offer笔记/</a>
    <span class="copy-path"  title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="ztzhang.cn/2018/08/26/剑指offer笔记/"  aria-label="复制成功！"></i></span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>  
</div>
<script> 
    var clipboard = new Clipboard('.fa-clipboard');
    $(".fa-clipboard").click(function(){
      clipboard.on('success', function(){
        swal({   
          title: "",   
          text: '复制成功',
          icon: "success", 
          showConfirmButton: true
          });
    });
    });  
</script>


      
    </div>
    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/08/03/SSM框架/" rel="next" title="SSM框架">
                <i class="fa fa-chevron-left"></i> SSM框架
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/09/06/Java-字符串深入/" rel="prev" title="Java 字符串深入">
                Java 字符串深入 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="KingSoul" />
            
              <p class="site-author-name" itemprop="name">KingSoul</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java内存的堆和栈"><span class="nav-number">1.</span> <span class="nav-text">Java内存的堆和栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM内存区域的划分"><span class="nav-number">2.</span> <span class="nav-text">JVM内存区域的划分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#常量池"><span class="nav-number">2.1.</span> <span class="nav-text">常量池</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参数的值传递与引用传递"><span class="nav-number">3.</span> <span class="nav-text">参数的值传递与引用传递</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本数据类型"><span class="nav-number">3.1.</span> <span class="nav-text">基本数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String类型"><span class="nav-number">3.2.</span> <span class="nav-text">String类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象"><span class="nav-number">3.3.</span> <span class="nav-text">对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#哈希表"><span class="nav-number">4.</span> <span class="nav-text">哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是哈希表？"><span class="nav-number">4.1.</span> <span class="nav-text">什么是哈希表？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用哈希表的例子"><span class="nav-number">4.2.</span> <span class="nav-text">使用哈希表的例子</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第一个只出现一次的字符"><span class="nav-number">4.2.1.</span> <span class="nav-text">第一个只出现一次的字符</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于数组的面试题"><span class="nav-number">5.</span> <span class="nav-text">关于数组的面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数组中重复的数字"><span class="nav-number">5.1.</span> <span class="nav-text">数组中重复的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#用哈希表"><span class="nav-number">5.1.1.</span> <span class="nav-text">用哈希表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#更有效的方法"><span class="nav-number">5.1.2.</span> <span class="nav-text">更有效的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不修改数组找数组中重复的数字"><span class="nav-number">5.1.3.</span> <span class="nav-text">不修改数组找数组中重复的数字</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#旋转数组中的最小数字"><span class="nav-number">5.2.</span> <span class="nav-text">旋转数组中的最小数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二维数组中的查找"><span class="nav-number">5.3.</span> <span class="nav-text">二维数组中的查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在排序数组中查找数字"><span class="nav-number">5.4.</span> <span class="nav-text">在排序数组中查找数字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数字在排序数组中出现的次数"><span class="nav-number">5.4.1.</span> <span class="nav-text">数字在排序数组中出现的次数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#0-n中缺失的数字"><span class="nav-number">5.4.2.</span> <span class="nav-text">0~n中缺失的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#解法一-O-n"><span class="nav-number">5.4.2.1.</span> <span class="nav-text">解法一: O(n)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#解法二：O-log2-n"><span class="nav-number">5.4.2.2.</span> <span class="nav-text">解法二：O(log2(n))</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数值与下标相等的元素"><span class="nav-number">5.4.3.</span> <span class="nav-text">数值与下标相等的元素</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组中数字出现的次数"><span class="nav-number">5.5.</span> <span class="nav-text">数组中数字出现的次数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数组中只出现一次的两个数字"><span class="nav-number">5.5.1.</span> <span class="nav-text">数组中只出现一次的两个数字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组中唯一只出现一次的数字"><span class="nav-number">5.5.2.</span> <span class="nav-text">数组中唯一只出现一次的数字</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#和为s的数字"><span class="nav-number">5.6.</span> <span class="nav-text">和为s的数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#和为s的连续正数序列"><span class="nav-number">5.7.</span> <span class="nav-text">和为s的连续正数序列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链表"><span class="nav-number">6.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#从尾到头打印链表"><span class="nav-number">6.1.</span> <span class="nav-text">从尾到头打印链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#那些关于二叉树的事儿"><span class="nav-number">7.</span> <span class="nav-text">那些关于二叉树的事儿</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#重建二叉树"><span class="nav-number">7.1.</span> <span class="nav-text">重建二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树的下一个节点"><span class="nav-number">7.2.</span> <span class="nav-text">二叉树的下一个节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有序二叉树中，求两个节点的最低公共祖先"><span class="nav-number">7.3.</span> <span class="nav-text">有序二叉树中，求两个节点的最低公共祖先</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉搜索树的从小到大的第k个节点"><span class="nav-number">7.4.</span> <span class="nav-text">二叉搜索树的从小到大的第k个节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树的深度"><span class="nav-number">7.5.</span> <span class="nav-text">二叉树的深度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#判断某棵树是否是平衡二叉树"><span class="nav-number">7.6.</span> <span class="nav-text">判断某棵树是否是平衡二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#序列化二叉树"><span class="nav-number">7.7.</span> <span class="nav-text">序列化二叉树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#递归思想与回溯法"><span class="nav-number">8.</span> <span class="nav-text">递归思想与回溯法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#递归"><span class="nav-number">8.1.</span> <span class="nav-text">递归</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#斐波那契数列"><span class="nav-number">8.1.1.</span> <span class="nav-text">斐波那契数列</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#不好的方法（递归）"><span class="nav-number">8.1.1.1.</span> <span class="nav-text">不好的方法（递归）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#利用循环实现"><span class="nav-number">8.1.1.2.</span> <span class="nav-text">利用循环实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#斐波那契数列的应用"><span class="nav-number">8.1.1.3.</span> <span class="nav-text">斐波那契数列的应用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串的全排列"><span class="nav-number">8.1.2.</span> <span class="nav-text">字符串的全排列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#八皇后问题"><span class="nav-number">8.1.3.</span> <span class="nav-text">八皇后问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回溯法"><span class="nav-number">8.2.</span> <span class="nav-text">回溯法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#矩阵中的路径"><span class="nav-number">8.2.1.</span> <span class="nav-text">矩阵中的路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#机器人的运动范围"><span class="nav-number">8.2.2.</span> <span class="nav-text">机器人的运动范围</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#回溯法求解图的着色问题"><span class="nav-number">8.2.3.</span> <span class="nav-text">回溯法求解图的着色问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-栈与队列"><span class="nav-number">9.</span> <span class="nav-text">Java 栈与队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#栈"><span class="nav-number">9.1.</span> <span class="nav-text">栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#队列"><span class="nav-number">9.2.</span> <span class="nav-text">队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于栈和队列的题目"><span class="nav-number">9.3.</span> <span class="nav-text">关于栈和队列的题目</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#用两个栈实现队列"><span class="nav-number">9.3.1.</span> <span class="nav-text">用两个栈实现队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#包含min函数的栈"><span class="nav-number">9.3.2.</span> <span class="nav-text">包含min函数的栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#滑动窗口的最大值"><span class="nav-number">9.3.3.</span> <span class="nav-text">滑动窗口的最大值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态规划与贪婪算法"><span class="nav-number">10.</span> <span class="nav-text">动态规划与贪婪算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#动态规划"><span class="nav-number">10.1.</span> <span class="nav-text">动态规划</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#贪婪算法"><span class="nav-number">10.2.</span> <span class="nav-text">贪婪算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#例子"><span class="nav-number">10.3.</span> <span class="nav-text">例子</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#位运算"><span class="nav-number">11.</span> <span class="nav-text">位运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#输入一个整数求其二进制数中的1的个数"><span class="nav-number">11.1.</span> <span class="nav-text">输入一个整数求其二进制数中的1的个数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#翻转字符串"><span class="nav-number">12.</span> <span class="nav-text">翻转字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#翻转单词顺序"><span class="nav-number">12.1.</span> <span class="nav-text">翻转单词顺序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#方法1：使用String的split函数，将句子先分为几个单词，之后只需调换单词的顺序即可；"><span class="nav-number">12.1.1.</span> <span class="nav-text">方法1：使用String的split函数，将句子先分为几个单词，之后只需调换单词的顺序即可；</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法2："><span class="nav-number">12.1.2.</span> <span class="nav-text">方法2：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法3："><span class="nav-number">12.1.3.</span> <span class="nav-text">方法3：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#左旋转字符串"><span class="nav-number">12.2.</span> <span class="nav-text">左旋转字符串</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#抽象建模"><span class="nav-number">13.</span> <span class="nav-text">抽象建模</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#扑克牌中的顺子"><span class="nav-number">13.1.</span> <span class="nav-text">扑克牌中的顺子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#约瑟夫环问题"><span class="nav-number">13.2.</span> <span class="nav-text">约瑟夫环问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#求1-2-···-n"><span class="nav-number">13.3.</span> <span class="nav-text">求1+2+···+n;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不用-做加法运算"><span class="nav-number">13.4.</span> <span class="nav-text">不用+ - * /做加法运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不使用中间变量交换两个变量的值"><span class="nav-number">13.5.</span> <span class="nav-text">不使用中间变量交换两个变量的值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基于加减法"><span class="nav-number">13.5.1.</span> <span class="nav-text">基于加减法</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KingSoul</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">26.4k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
