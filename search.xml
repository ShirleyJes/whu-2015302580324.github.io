<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title></title>
      <link href="/2018/11/16/post-get/"/>
      <url>/2018/11/16/post-get/</url>
      
        <content type="html"><![CDATA[<p>��---<br><br>layout: http<br><br>title: post/get<br><br>date: 2018-11-16 22:51:39<br><br>tags:<br><br>---<br><br>&lt;!--more--&gt;<br><br># GET �e�l<br><br>�g�W[&amp;{2N�<br>T�y/&lt;P�[    �/f(W GET ��Bl�v URL -N�S��v�<br><br><br><br>GET /test/demo<em>form.asp?name1=value1&amp;name2=value2 HTTP/1.1<br><br>    gsQ GET ��Bl�vvQ�NN�N�lʑ�<br><br><br><br>GET ��Bl�S��X[<br><br>GET ��Bl�OYu(WOmȉhV�S�S��U</em>-N<br><br>GET ��Bl�S��6eυ:NfN~{<br><br>GET ��Bl<br>N�^(WYtOeapenc�eO(u<br><br>GET ��Bl    g��^P�6R�<br>N����Ǐ256*NW[&amp;{<br><br>GET ��Bl�S�^S_(u�N�S�Vpenc<br><br><br><br># POST <br><br>�g�W[&amp;{2N�<br>T�y/&lt;P�[    �/f(W POST ��Bl�v HTTP �mo<code>;NSO-N�S��v�POST /test/demo_form.asp HTTP/1.1Host: w3schools.comname1=value1&amp;name2=value2# ;</code>�~<br><br>post8^(ueg�c�Nh�USpenc��O�Y<br>N O(u7bD��e0<br>N O�e�N0</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>数据库</title>
      <link href="/2018/10/14/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2018/10/14/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>特征：A（atomicity）C(consistency) I (isolation) D(durability)</p><ul><li>原子性;</li><li>一致性:</li><li>隔离性：通常来说，一个事务所做的修改在最终提交之前对其他事务是不可见的</li><li>持久性；<br>如果事务中任何一条语句崩溃或因为其他原因无法执行，那么所有的语句都不会执行；要么全部commit成功，要么全部失败回滚（rollback）;<br>MySql：<br>START TRANSACTION;<br>//若干条SQL语句<br>COMMIT;</li></ul><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">脏读：读取未提交的数据；</span><br><span class="line">幻读：某个事务在读取某个范围内的记录时，另一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录的时候会产生幻行；</span><br></pre></td></tr></table></figure><p>事务的隔离性其实比较复杂，在SQL中定义了4种隔离级别，每一种都规定了一个事务做的修改，那些==哪些是在事务内和事务间可见，哪些是不可见的；</p><ul><li><p>read uncommited(未提交读)：该级别中，事务的修改，即使没有提交，对其他事务也都是可见的；这使得事务可以读取未提交的数据（脏读）；</p></li><li><p>read commited(提交读)：大多数数据库的默认级别（MySQL不是），一个事务从开始到提交前所做的修改对其他事务是不可见的这个级别也叫不可重复读（nonrepeatable)，因为两次执行同样的查询，可能得到不一样的结果；</p></li><li><p>repeatable read(可重复读)：（MySQL的默认级别）同一个事务中多次读取同样的记录的结果是一致的</p></li><li>serializable (可串行化)</li></ul><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>两个或者多个事务在同一个资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">事务1：</span><br><span class="line">start transaction;</span><br><span class="line">update StockPrice set close=45 where stock_id=4;</span><br><span class="line">update StockPrice set close=49 where stock_id=3;</span><br><span class="line">commit;</span><br><span class="line">update</span><br><span class="line">事务2：</span><br><span class="line">start transaction;</span><br><span class="line">update StockPrice set high=20 where stock_id=3;</span><br><span class="line">update StockPrice set high=18 where stock_id=4;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><p>如果此时两个事务都执行了第一条 update语句，更新了一行数据，同时也锁定了该行数据，接着每个事务都尝试执行第二条update语句，却发现该行已经被对方锁定，然后两个事务都等待对方释放锁，同时又持有对方需要的锁，则陷入死循环，除非右外部的因素介入才能解除死锁；</p><p>解决办法：</p><ul><li>死锁检测</li><li>死锁超时机制（查询时间超过超时的设定之后放弃锁请求）</li><li>将持有最少级联排他锁的事务进行回滚 </li></ul><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p><a href="https://www.cnblogs.com/newpanderking/p/3781043.html" target="_blank" rel="noopener">https://www.cnblogs.com/newpanderking/p/3781043.html</a><br>索引采用了平衡树的数据结构（B-Tree)，索引使写入数据的速度下降，原因很简单的， 因为平衡树这个结构必须一直维持在一个正确的状态， 增删改数据都会改变平衡树各节点中的索引数据内容，破坏树结构， 因此，在每次数据改变时， DBMS必须去重新梳理树（索引）的结构以确保它的正确，这会带来不小的性能开销；</p><p>对于小型的表，大部分情况下全表扫描更加有效。对于中型到大型的表，索引非常有效，但是对于特大型的表，建立和使用索引的代价将随之增长；</p><p>对数据库索引的理解<br>1、首先要明白无名无实莫要用索引：因为数据中的记录很多，为了方便我们查找，提高查询的效率；</p><p>2、索引的原理：对要查询的字段建立索引其实就是把该字段按照一定的方式排序；建立的索引只对该字段有用，如果查询的字段改变，那么这个索引也就无效了，比如图书馆的书是按照书名的第一个字母排序的，那么你想要找作者叫张三的就不能用该索引了；还有就是如果索引太多会降低查询的速度</p><h2 id="索引优缺点"><a href="#索引优缺点" class="headerlink" title="索引优缺点"></a>索引优缺点</h2><p>   首先明白为什么索引会增加速度，DB在执行一条Sql语句的时候，默认的方式是根据搜索条件进行全表扫描，遇到匹配条件的就加入搜索结果集合。如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，大大减少遍历匹配的行数，所以能明显增加查询的速度。那么在任何时候都应该加索引么？这里有几个反例：1、如果每次都需要取到所有表记录，无论如何都必须进行全表扫描了，那么是否加索引也没有意义了。2、对非唯一的字段，例如“性别”这种大量重复值的字段，增加索引也没有什么意义。3、对于记录比较少的表，增加索引不会带来速度的优化反而浪费了存储空间，因为索引是需要存储空间的，而且有个致命缺点是对于update/insert/delete的每次执行，字段的索引都必须重新计算更新。所以并不是任何情况下都改建立索引的</p><p>以下内容转自：<a href="http://blog.csdn.net/sky_zhangfan/article/details/3404950" target="_blank" rel="noopener">http://blog.csdn.net/sky_zhangfan/article/details/3404950</a></p><p>一、为什么要创建索引呢（优点）？<br>这是因为，创建索引可以大大提高系统的性能。<br>第一，   通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。<br>第二，   可以大大加快数据的检索速度，这也是创建索引的最主要的原因。<br>第三，   可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。<br>第四，   在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。<br>第五，   通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p><p>二、建立方向索引的不利因素（缺点）<br>也许会有人要问：增加索引有如此多的优点，为什么不对表中的每一个列创建一个索引呢？这种想法固然有其合理性，然而也有其片面性。虽然，索引有许多优点，但是，为表中的每一个列都增加索引，是非常不明智的。这是因为，增加索引也有许多不利的一个方面。</p><p>第一，   创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。<br>第二，   索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。<br>第三，   当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</p><h2 id="创建索引的方法"><a href="#创建索引的方法" class="headerlink" title="创建索引的方法"></a>创建索引的方法</h2><p>创建索引有多种方法，这些方法包括直接创建索引的方法和间接创建索引的方法。<br>第一，   直接创建索引，例如使用CREATE INDEX语句或者使用创建索引向导。<br>第二，   间接创建索引，例如在表中定义主键约束或者唯一性键约束时，同时也创建了索引。<br>虽然，这两种方法都可以创建索引，但是，它们创建索引的具体内容是有区别的。<br>使 用CREATE INDEX语句或者使用创建索引向导来创建索引，这是最基本的索引创建方式，并且这种方法最具有柔性，可以定制创建出符合自己需要的索引。在使用这种方式 创建索引时，可以使用许多选项，例如指定数据页的充满度、进行排序、整理统计信息等，这样可以优化索引。使用这种方法，可以指定索引的类型、唯一性和复合 性，也就是说，既可以创建聚簇索引，也可以创建非聚簇索引，既可以在一个列上创建索引，也可以在两个或者两个以上的列上创建索引。<br>通过定义主 键约束或者唯一性键约束，也可以间接创建索引。主键约束是一种保持数据完整性的逻辑，它限制表中的记录有相同的主键记录。在创建主键约束时，系统自动创建 了一个唯一性的聚簇索引。虽然，在逻辑上，主键约束是一种重要的结构，但是，在物理结构上，与主键约束相对应的结构是唯一性的聚簇索引。换句话说，在物理 实现上，不存在主键约束，而只存在唯一性的聚簇索引。同样，在创建唯一性键约束时，也同时创建了索引，这种索引则是唯一性的非聚簇索引。因此，当使用约束 创建索引时，索引的类型和特征基本上都已经确定了，由用户定制的余地比较小。<br>当在表上定义主键或者唯一性键约束时，如果表中已经有了使用 CREATE INDEX语句创建的标准索引时，那么主键约束或者唯一性键约束创建的索引覆盖以前创建的标准索引。也就是说，主键约束或者唯一性键约束创建的索引的优先 级高于使用CREATE INDEX语句创建的索引。<br>五、索引的特征  </p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java多线程</title>
      <link href="/2018/10/03/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2018/10/03/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>进程：是执行中一段程序，即一旦程序被载入到内存中并准备执行，它就是一个进程。进程是系统进行资源分配和调度的一个独立单位。</p><p>线程：一个程序执行多个任务，每个任务就是一个线程。线程是进程中执行运算的最小单位。是CPU调度和分派的基本单位。</p><p>一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.</p><p>相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。<br><a href="https://www.cnblogs.com/lgk8023/p/6430592.html" target="_blank" rel="noopener">https://www.cnblogs.com/lgk8023/p/6430592.html</a><br><a href="https://blog.csdn.net/qq_33573235/article/details/76588639" target="_blank" rel="noopener">https://blog.csdn.net/qq_33573235/article/details/76588639</a><br><a id="more"></a></p><h2 id="线程的生命周期及五种基本状态"><a href="#线程的生命周期及五种基本状态" class="headerlink" title="线程的生命周期及五种基本状态"></a>线程的生命周期及五种基本状态</h2><ul><li><p>新建状态（New）：当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread();</p></li><li><p>就绪状态（Runnable）：当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；</p></li><li><p>运行状态（Running）：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就     绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；</p></li><li><p>阻塞状态（Blocked）：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：</p><ul><li><p>等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；</p></li><li><p>同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；</p></li><li><p>其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</p></li></ul></li><li><p>死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</p><h2 id="java线程的创建"><a href="#java线程的创建" class="headerlink" title="java线程的创建"></a>java线程的创建</h2><h3 id="继承Thread类，重写该类的run-方法"><a href="#继承Thread类，重写该类的run-方法" class="headerlink" title="继承Thread类，重写该类的run()方法"></a>继承Thread类，重写该类的run()方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadTest &#123;</span><br><span class="line">    static class MyThread extends Thread &#123;</span><br><span class="line">        private int i = 0;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);</span><br><span class="line">            if (i == 2) &#123;</span><br><span class="line">                Thread myThread1 = new MyThread();     // 创建一个新的线程  myThread1  此线程进入新建状态</span><br><span class="line">                Thread myThread2 = new MyThread();     // 创建一个新的线程 myThread2 此线程进入新建状态</span><br><span class="line">                myThread1.start();                     // 调用start()方法使得线程进入就绪状态</span><br><span class="line">                myThread2.start();                     // 调用start()方法使得线程进入就绪状态</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">第一次输出：                  第二次输出：</span><br><span class="line">main 0main 0</span><br><span class="line">main 1main 1</span><br><span class="line">main 2                      main 2</span><br><span class="line">main 3main 3</span><br><span class="line">main 4main 4</span><br><span class="line">Thread-0 0Thread-0 0</span><br><span class="line">Thread-0 1Thread-1 0</span><br><span class="line">Thread-0 2Thread-0 1</span><br><span class="line">Thread-1 0Thread-1 1</span><br><span class="line">Thread-1 1Thread-0 2</span><br><span class="line">Thread-1 2Thread-1 2</span><br><span class="line">上述输出表明线程的执行是具有不确定性的</span><br></pre></td></tr></table></figure><p>其中run()方法的方法体代表了线程需要完成的任务，称之为线程执行体。当创建此线程类对象时一个新的线程得以创建，并进入到线程新建状态。通过调用线程对象引用的start()方法，使得该线程进入到就绪状态，此时此线程并不一定会马上得以执行，这取决于CPU调度时机。</p><h3 id="实现Runnable接口，并重写该接口的run-方法"><a href="#实现Runnable接口，并重写该接口的run-方法" class="headerlink" title="实现Runnable接口，并重写该接口的run()方法"></a>实现Runnable接口，并重写该接口的run()方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadTest &#123;</span><br><span class="line">    static class MyRunnable implements Runnable &#123;</span><br><span class="line">        private int i = 0;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);</span><br><span class="line">            if (i == 3) &#123;</span><br><span class="line">                Runnable myRunnable = new MyRunnable(); // 创建一个Runnable实现类的对象</span><br><span class="line">                Thread thread1 = new Thread(myRunnable); // 将myRunnable作为Thread target创建新的线程</span><br><span class="line">                Thread thread2 = new Thread(myRunnable);</span><br><span class="line">                thread1.start(); // 调用start()方法使得线程进入就绪状态</span><br><span class="line">                thread2.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Thread和Runnable之间的关系"><a href="#Thread和Runnable之间的关系" class="headerlink" title="Thread和Runnable之间的关系"></a>Thread和Runnable之间的关系</h2><h3 id="从代码上看"><a href="#从代码上看" class="headerlink" title="从代码上看"></a>从代码上看</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">----------------------------Thread类----------------------------------</span><br><span class="line">public class Thread implements Runnable&#123;</span><br><span class="line">  private Runnable target;</span><br><span class="line">//Thread实现Runnable接口，但是并没有完全实现run() 方法,此方法是Runnable子类完成的，所以如果继承Thread就必须覆写run方法</span><br><span class="line">@Override</span><br><span class="line"> public void run()&#123;</span><br><span class="line">  if(!target != null)&#123;</span><br><span class="line">    target.run();</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">---------------------------Runnable 接口------------------------------</span><br><span class="line">public interface Runnable&#123;</span><br><span class="line">  public abstract void run();</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------------------</span><br></pre></td></tr></table></figure><h3 id="资源是否共享"><a href="#资源是否共享" class="headerlink" title="资源是否共享"></a>资源是否共享</h3><p>一个类继承Thread，不适合多个线程共享资源；<br>实现Runnable接口，可以方便实现资源共享；</p><p>因为一个线程只能启动一次，通过Thread实现线程时，线程和线程所要执行的任务是捆绑在一起的。也就使得一个任务只能启动一个线程，不同的线程执行的任务是不相同的，所以没有必要，也不能让两个线程共享彼此任务中的资源。</p><p>一个任务可以启动多个线程，通过Runnable方式实现的线程，实际是开辟一个线程，将任务传递进去，由此线程执行。可以实例化多个 Thread对象，将同一任务传递进去，也就是一个任务可以启动多个线程来执行它。这些线程执行的是同一个任务，所以他们的资源是共享。</p><p>两种不同的线程实现方式本身就决定了其是否能进行资源共享。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>comparable和Comparator</title>
      <link href="/2018/09/30/comparable%E5%92%8CComparator/"/>
      <url>/2018/09/30/comparable%E5%92%8CComparator/</url>
      
        <content type="html"><![CDATA[<p>资料：<a href="https://www.cnblogs.com/xujian2014/p/5215082.html" target="_blank" rel="noopener">https://www.cnblogs.com/xujian2014/p/5215082.html</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>最长公共子序列</title>
      <link href="/2018/09/29/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>/2018/09/29/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>最长上升子序列</title>
      <link href="/2018/09/16/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>/2018/09/16/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>最长上升子序列(LIS)：就是在一个给定的序列中找到一个递增的尽可能长的序列，这个序列不一定是连续的或者唯一的。<br>例如：<br>[4,2,4,5,3,7], 返回[2,4,5,7]</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>资料：<a href="https://blog.csdn.net/iNiegang/article/details/47379873" target="_blank" rel="noopener">https://blog.csdn.net/iNiegang/article/details/47379873</a><br>使用动态规划，记f(i)表示数组L中以ai为末元素（即ai为该序列的最大元素）的最长递增子序列的长度，找到所有序号在L前面且小于ai的元素aj，即j&lt;i且aj&lt;ai。如果这样的元素存在，那么对所有aj,都有一个以aj为末元素的最长递增子序列的长度f(j)，把其中最大的f(j)选出来，那么f(i)就等于最大的f(j)加上1，即以ai为末元素的最长递增子序列，等于以使f(j)最大的那个aj为末元素的递增子序列最末再加上ai；如果这样的元素不存在，那么ai自身构成一个长度为1的以ai为末元素的递增子序列。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>面试题42：连续子数组的最大和</title>
      <link href="/2018/09/12/%E9%9D%A2%E8%AF%95%E9%A2%9842%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
      <url>/2018/09/12/%E9%9D%A2%E8%AF%95%E9%A2%9842%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>DFS</title>
      <link href="/2018/09/11/DFS/"/>
      <url>/2018/09/11/DFS/</url>
      
        <content type="html"><![CDATA[<p>深度优先搜索属于图算法的一种，英文缩写为DFS即Depth First Search.其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次.涉及递归和回溯。<br><a id="more"></a></p><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class FullPermutation &#123;</span><br><span class="line">    private static String [] result;//存放全排列的结果</span><br><span class="line">    private static boolean [] visit;//定义一个标记数组</span><br><span class="line">    private static int n; //全排列的长度</span><br><span class="line">    private static String data[];</span><br><span class="line"></span><br><span class="line">    private static void dfs(int count)&#123;</span><br><span class="line">        if(count==n)&#123;</span><br><span class="line">            System.out.println(Arrays.toString(result));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //每一次遍历都有n个选择</span><br><span class="line">        for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">            if(!visit[i])&#123;</span><br><span class="line">                visit[i] = true;</span><br><span class="line">                result[count] = data[i];</span><br><span class="line">                dfs(count+1); </span><br><span class="line">               //回溯</span><br><span class="line">                visit[i] = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        n = 4;//以长度为5举例</span><br><span class="line">        result = new String[n];</span><br><span class="line">        visit = new boolean[n];</span><br><span class="line">        Arrays.fill(visit,false);</span><br><span class="line">        data=new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;&#125;;</span><br><span class="line">        dfs(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h3><p>定义一个二维数组N*M（其中2&lt;=N&lt;=10;2&lt;=M&lt;=10），如5 × 5数组下所示：<br>int maze[5][5] = {<br> 0, 1, 0, 0, 0,<br> 0, 1, 0, 1, 0,<br>0, 0, 0, 0, 0,<br>0, 1, 1, 1, 0,<br> 0, 0, 0, 1, 0,<br>};<br>它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。入口点为[0,0],既第一空格是可以走的路。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public class Main&#123;</span><br><span class="line">        </span><br><span class="line">    public static void main(String[] arg)&#123;</span><br><span class="line">        Scanner s=new Scanner(System.in);</span><br><span class="line">        while(s.hasNext())&#123;</span><br><span class="line">            String q=s.nextLine();</span><br><span class="line">            String[] q1=q.split(&quot; &quot;);</span><br><span class="line">            int n=Integer.valueOf(q1[0]);</span><br><span class="line">            int m=Integer.valueOf(q1[1]);</span><br><span class="line">            //得到矩阵数组</span><br><span class="line">            int[][] arr=new int[n][m];</span><br><span class="line">            //初始化标记数组</span><br><span class="line">            boolean [][] b = new boolean[n][m];</span><br><span class="line">            //因为右下角的矩阵值一定是0（出口）,所以标记改点为true表示可以通过</span><br><span class="line">            b[n-1][m-1]=true;</span><br><span class="line">            for (int i=0;i&lt;n;i++)&#123;</span><br><span class="line">                String w=s.nextLine();</span><br><span class="line">                String[] r=w.split(&quot; &quot;);</span><br><span class="line">                for (int j=0;j&lt;r.length;j++)</span><br><span class="line">                    arr[i][j]=Integer.valueOf(r[j]);</span><br><span class="line">            &#125;</span><br><span class="line">              </span><br><span class="line">            haspath(arr, b, 0, 0, n, m);</span><br><span class="line">            for (int i = 0; i &lt; b.length; i++) &#123;</span><br><span class="line">                for (int j = 0; j &lt; b[0].length; j++) &#123;</span><br><span class="line">                    if (b[i][j]) &#123;</span><br><span class="line">                        System.out.println(&quot;(&quot;+i+&quot;,&quot;+j+&quot;)&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">              </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //通过这个方法将标记数组初始化，b[i][j]==true表明可以通过</span><br><span class="line">public static boolean haspath(int[][] arr,boolean [][] b, int n,int m,int nlength,int mlength) &#123;</span><br><span class="line">        boolean flag = false;</span><br><span class="line">        if (n==nlength -2&amp;&amp;m ==mlength-1&amp;&amp;arr[n][m]==0) &#123;</span><br><span class="line">            b[n][m]=true;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (m==mlength -2&amp;&amp;n ==nlength-1&amp;&amp;arr[n][m]==0) &#123;</span><br><span class="line">            b[n][m]=true;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (m&gt;=mlength||n&gt;=nlength) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; </span><br><span class="line">        if (arr[n][m]==0&amp;&amp;!b[n][m]) &#123;</span><br><span class="line">            b[n][m] = true;</span><br><span class="line">            flag = haspath(arr, b, n+1, m, nlength, mlength)||haspath(arr, b, n, m+1, nlength, mlength);</span><br><span class="line">        &#125;</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            return flag;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            b[n][m] = false;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Main&#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] arg)&#123;</span><br><span class="line">        Scanner s=new Scanner(System.in);</span><br><span class="line">        while(s.hasNext())&#123;</span><br><span class="line">            String q=s.nextLine();</span><br><span class="line">            String[] q1=q.split(&quot; &quot;);</span><br><span class="line">            int n=Integer.valueOf(q1[0]);</span><br><span class="line">            int m=Integer.valueOf(q1[1]);</span><br><span class="line">            //得到矩阵数组</span><br><span class="line">            int[][] arr=new int[n][m];</span><br><span class="line">            //初始化标记数组</span><br><span class="line">            boolean [][] b = new boolean[n][m];</span><br><span class="line">            //因为右下角的矩阵值一定是0（出口）,所以标记改点为true表示可以通过</span><br><span class="line">            b[n-1][m-1]=true;</span><br><span class="line">            for (int i=0;i&lt;n;i++)&#123;</span><br><span class="line">                String w=s.nextLine();</span><br><span class="line">                String[] r=w.split(&quot; &quot;);</span><br><span class="line">                for (int j=0;j&lt;r.length;j++)</span><br><span class="line">                    arr[i][j]=Integer.valueOf(r[j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            hasPath(arr, b, n, m,0, 0 );</span><br><span class="line">            for (int i = 0; i &lt; b.length; i++) &#123;</span><br><span class="line">                for (int j = 0; j &lt; b[0].length; j++) &#123;</span><br><span class="line">                    if (b[i][j]) &#123;</span><br><span class="line">                        System.out.println(&quot;(&quot;+i+&quot;,&quot;+j+&quot;)&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //通过这个方法将标记数组初始化，b[i][j]==true表明可以通过</span><br><span class="line">    public static void hasPath(int[][]matrix,boolean[][]b,int rows,int cols,int i,int j)&#123;</span><br><span class="line">        if(matrix==null||rows&lt;1||cols&lt;1) return ;</span><br><span class="line">        if((i==rows-2&amp;&amp;j==cols-1&amp;&amp;matrix[i][j]==0)||i==rows-1&amp;&amp;j==cols-2&amp;&amp;matrix[i][j]==0)&#123;</span><br><span class="line">            b[i][j]=true;</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i&gt;=rows||j&gt;=cols)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(matrix[i][j]==0&amp;&amp;!b[i][j])&#123;</span><br><span class="line">            b[i][j]=true;</span><br><span class="line">            hasPath(matrix,b,rows,cols,i+1,j);</span><br><span class="line">            hasPath(matrix,b,rows,cols,i,j+1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>排序算法</title>
      <link href="/2018/09/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2018/09/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>选择排序、插入排序、冒泡排序、快速排序、归并排序、堆排序<br><a id="more"></a></p><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>首先，在R[1]~R[n]中选出排序码最小的元素，将它与R[1]交换位置；然后，在R[2]~R[n]中选出排序码最小的元素，将它与R[2]交换位置；依<br>次做下去，在进行了n–1次选择后排序过程结束。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//大跨度，不稳定排序，算法必须进行n-1趟比较次数一定为n(n-1)/2;</span><br><span class="line">    public static void selectsort(int a[])&#123;</span><br><span class="line">        for (int i=0;i&lt;a.length-1;i++)&#123;</span><br><span class="line">            int index=i;</span><br><span class="line">            for(int j=i+1;j&lt;a.length;j++)&#123;</span><br><span class="line">                if(a[j]&lt;a[index])&#123;</span><br><span class="line">                    index=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(index!=i)swap(a,i,index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><ul><li><p>排序码比较次数和初始排列顺序无关：第1次选择比较n–1次，第2次选择比较n–2次……第n–1次选择比较1次，总的比较次数为：n(n-1)/2;               </p></li><li><p>元素移动次数和初始排列顺序有关：如果R[1]~R[n]原来就是从小到大排列的，就不需要移动；如果每次选择都要进行交换，移动次数将达到最大值，即3(n–1)次。</p></li><li><p>算法的执行时间为O(n^2)。</p></li><li><p>简单选择排序是不稳定的排序 。</p><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>首先，将R[1]看成是一个有序表，将R[2]插入其中，得到有2个元素的有序表；然后，将R[3]插入到这个有序表中，得到有3个元素的有序表；依次进行下去，直到有序表的长度等于n为止。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//稳定排序，算法必须进行n-1趟比较次数一定为n(n-1)/2;</span><br><span class="line">    public static void insertsort(int a[])&#123;</span><br><span class="line">        for(int i=1;i&lt;a.length;i++)&#123;</span><br><span class="line">            int j=i;</span><br><span class="line">            int temp=a[i];</span><br><span class="line">            while (j&gt;0&amp;&amp;temp&lt;a[j-1])&#123;</span><br><span class="line">                a[j]=a[j-1];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            a[j]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><ul><li>往长度为 i–1 的有序表中插入一个新元素，排序码的比较次数最少是一次(留在原处)，最多是 i 次(插到最前面)；元素的移动次数比排序码比较次数多一次（包括R[0]的移动）。<ul><li>最少比较n–1次，最多比较（n+2）(n-1)/2 次；    </li><li>最少移动2(n–1)次，最多移动  (n+4)(n-1)/2  次。</li></ul></li></ul><p>因此，算法的执行时间在最坏的情况下是O(n^2)。</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h3><p>首先，在 R[1]~R[n] 范围内，依次比较两个相邻元素的排序码，若 R[i] 较大<br>则交换 R[i]和 R[i+1]，否则就不交换(i=1,2,…,n–1)，经过这样一遍处理（称为一趟冒泡），就把R[1]~R[n]中排序码最大的元素换到了R[n] 中；然后，在R[1]~R[n–1]范围内，再进行一趟冒泡，将该范围内排序码最大的元素换到R[n–1]中；依次进行下去，最多只要进行n–1趟冒泡。如果在某趟冒泡过程中没有出现相邻元素交换位置的情况，则说明已达到排序要求，可提前结束处理过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//稳定排序</span><br><span class="line">   public static void bubblesort(int a[])&#123;</span><br><span class="line">       int i,last;</span><br><span class="line">       i=a.length-1;</span><br><span class="line">       while (i&gt;0)&#123;//最多进行n-1趟</span><br><span class="line">           last=0;</span><br><span class="line">           for(int j=0;j&lt;i;j++)&#123;</span><br><span class="line">               if(a[j]&gt;a[j+1]) &#123;</span><br><span class="line">                   swap(a,j,j+1);</span><br><span class="line">                   last=j;//有交换就将last置为j</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           i=last;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h3 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h3><ul><li>如果n个元素已经从小到大排好，则只要进行一趟冒泡，排序码比较次数最少，只要n–1次，而且不需要移动元素。</li><li><p>如果n个元素是从大到小排列的，则需要进行n–1趟起泡，排序码的比较次数和元素的移动次数都达到最大值，分别为  (n-1)n/2    次和       3(n-1)n/2     次 。</p></li><li><p>起泡排序的执行时间在最坏情况下是O(n^2)。</p></li></ul><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="基本思想-3"><a href="#基本思想-3" class="headerlink" title="基本思想"></a>基本思想</h3><p>首先，从R[1]~R[n]中任取一个元素，以该元素的排序码为标准把n个元素分成左右两组，即左边一组中所有元素的排序码都不大于标准元素的排序码，右边一组中所有元素的排序码都不小于标准元素的排序码，并将该标准元素放到这两组的中间；然后，用同样的方法分别对这两组元素再进行分组，如此反复进行，直到所有元素都被放到正确位置为止。<br>        用第一个元素为标准进行分组，采用从两端往中间夹入的方式为该元素找插入位置。 以第一次分组为例，首先，将R[1]存入R[0]中，引入变量i（初始值为1）和j（初始值为n），然后，比较R[0]和R[j]，若R[j]较大，则j减1，继续比较R[0]和R[j]；若R[j]较小，则将R[j]存入R[i]中，在i加1后，转而比较R[0]和R[i]的排序码：若R[i]较小，则<br>i加1，继续比较R[0]和R[i]；若R[i]较大，则将R[i]存入R[j]中，在j减1后，转而比较R[0]和R[j]。如此交替进行下去，直至i=j时，将R[0]存入R[j]中，一次分组过程便告结束。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public static void quickSort(int[] a) &#123;</span><br><span class="line">       if(a.length&gt;0) &#123;</span><br><span class="line">           quickSort(a, 0 , a.length-1);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private static void quickSort(int[] a, int low, int high) &#123;</span><br><span class="line">       //1,找到递归算法的出口</span><br><span class="line">       if( low &gt; high) &#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       //2, 存</span><br><span class="line">       int i = low;</span><br><span class="line">       int j = high;</span><br><span class="line">       //3,key</span><br><span class="line">       int key = a[ low ];</span><br><span class="line">       //4，完成一趟排序</span><br><span class="line">       while( i&lt; j) &#123;</span><br><span class="line">           //4.1 ，从右往左找到第一个小于key的数</span><br><span class="line">           while(i&lt;j &amp;&amp; a[j] &gt; key)&#123;</span><br><span class="line">               j--;</span><br><span class="line">           &#125;</span><br><span class="line">           // 4.2 从左往右找到第一个大于key的数</span><br><span class="line">           while( i&lt;j &amp;&amp; a[i] &lt;= key) &#123;</span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           //4.3 交换</span><br><span class="line">           if(i&lt;j) &#123;</span><br><span class="line">              swap(a,i,j);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       // 4.4，调整key的位置</span><br><span class="line">       swap(a,low,j);</span><br><span class="line">       //5, 对key左边的数快排</span><br><span class="line">       quickSort(a, low, j-1 );</span><br><span class="line">       //6, 对key右边的数快排</span><br><span class="line">       quickSort(a, j+1, high);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h3 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h3><p>平均执行时间为O(nlog2n)。<br> 如果每次分组结果都是将标准元素交换到待分组序列的最前面或最后面，则对于 n个元素来说，就需要进行n–1次分组，排序码比较次数达到最大值：n(n-1)/2。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="基本思想-4"><a href="#基本思想-4" class="headerlink" title="基本思想"></a>基本思想</h3><p>首先，将R[1]~R[n]看成是n个长度为1的有序表，将相邻的有序表成对归<br>并，得到n/2个长度为2的有序表；然后，再将这些有序表成对归并，得到n/4个长度为4的有序表，如此反复进行下去，最后得到一个长度为n的有序表。<br>       与前面介绍的几种排序方法不同，归并排序需要用到一个和R同类型的辅助数组S。</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><img src="/2018/09/08/排序算法/总结.png">]]></content>
      
      
      <categories>
          
          <category> 排序 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>HashMap</title>
      <link href="/2018/09/06/HashMap/"/>
      <url>/2018/09/06/HashMap/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是MAP"><a href="#什么是MAP" class="headerlink" title="什么是MAP"></a>什么是MAP</h2><p>在数组中我们是通过数组下标来对其内容索引的，而在Map中我们通过对象来对对象进行索引，用来索引的对象叫做key，其对应的对象叫做value。<br>HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap。<br>Java集合资料：<a href="https://www.cnblogs.com/skywang12345/p/3323085.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3323085.html</a><br><a id="more"></a><br><img src="/2018/09/06/HashMap/java集合框架图.png"></p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>HashMap是一个散列表，HashMap通过hashcode对其内容进行快速查找；<br>HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。</p><h3 id="HashMap-的API"><a href="#HashMap-的API" class="headerlink" title="HashMap 的API"></a>HashMap 的API</h3><p> clear()： void<br> clone()：Object<br> containsKey(Object key)：boolean<br>containsValue(Object value)：boolean<br>entrySet()：Set&lt;Entry&lt;K, V&gt;&gt;<br>get(Object key)：V<br> isEmpty()：boolean<br>keySet()：Set<k><br>put(K key, V value)：V<br>putAll(Map&lt;? extends K, ? extends V&gt; map)：void<br>remove(Object key)：V<br> size()：int<br>values()：Collection<v> </v></k></p><h3 id="HashMap遍历方式"><a href="#HashMap遍历方式" class="headerlink" title="HashMap遍历方式"></a>HashMap遍历方式</h3><h4 id="遍历HashMap的键值对"><a href="#遍历HashMap的键值对" class="headerlink" title="遍历HashMap的键值对"></a>遍历HashMap的键值对</h4><p>第一步：根据entrySet()获取HashMap的“键值对”的Set集合。<br>第二步：通过Iterator迭代器遍历“第一步”得到的集合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 假设map是HashMap对象</span><br><span class="line">// map中的key是String类型，value是Integer类型</span><br><span class="line">Integer integ = null;</span><br><span class="line">Iterator iter = map.entrySet().iterator();</span><br><span class="line">while(iter.hasNext()) &#123;</span><br><span class="line">    Map.Entry entry = (Map.Entry)iter.next();</span><br><span class="line">    // 获取key</span><br><span class="line">    key = (String)entry.getKey();</span><br><span class="line">        // 获取value</span><br><span class="line">    integ = (Integer)entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历HashMap的键"><a href="#遍历HashMap的键" class="headerlink" title="遍历HashMap的键"></a>遍历HashMap的键</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">第一步：根据keySet()获取HashMap的“键”的Set集合。</span><br><span class="line">第二步：通过Iterator迭代器遍历“第一步”得到的集合。</span><br><span class="line"></span><br><span class="line">复制代码</span><br><span class="line">// 假设map是HashMap对象</span><br><span class="line">// map中的key是String类型，value是Integer类型</span><br><span class="line">String key = null;</span><br><span class="line">Integer integ = null;</span><br><span class="line">Iterator iter = map.keySet().iterator();</span><br><span class="line">while (iter.hasNext()) &#123;</span><br><span class="line">        // 获取key</span><br><span class="line">    key = (String)iter.next();</span><br><span class="line">        // 根据key，获取value</span><br><span class="line">    integ = (Integer)map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历HashMap的值"><a href="#遍历HashMap的值" class="headerlink" title="遍历HashMap的值"></a>遍历HashMap的值</h4><p>第一步：根据value()获取HashMap的“值”的集合。<br>第二步：通过Iterator迭代器遍历“第一步”得到的集合。</p><pre><code>// 假设map是HashMap对象// map中的key是String类型，value是Integer类型Integer value = null;Collection c = map.values();Iterator iter= c.iterator();while (iter.hasNext()) {    value = (Integer)iter.next();}</code></pre><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>大多数情况下，只要不涉及线程安全问题，Map基本都可以使用HashMap，不过HashMap有一个问题，就是迭代HashMap的顺序并不是HashMap放置的顺序，也就是无序。HashMap的这一缺点往往会带来困扰，因为有些场景，我们期待一个有序的Map。</p><p>这个时候，LinkedHashMap就闪亮登场了，它虽然增加了时间和空间上的开销，但是通过维护一个运行于所有条目的双向链表，LinkedHashMap保证了元素迭代的顺序。该迭代顺序可以是插入顺序或者是访问顺序。</p><h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p>Hashtable 也是一个散列表，Hashtable 的函数都是同步的，这意味着它是线程安全的。它的key、value都不可以为null，Hashtable中的映射不是有序的。</p><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Java 字符串深入</title>
      <link href="/2018/09/06/Java-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%B1%E5%85%A5/"/>
      <url>/2018/09/06/Java-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%B1%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="String中常用的方法API"><a href="#String中常用的方法API" class="headerlink" title="String中常用的方法API"></a>String中常用的方法API</h1><p>replaceAll(,);<br>lastIndexOf();<br> <a href="https://blog.csdn.net/ss19497/article/details/53730759" target="_blank" rel="noopener">https://blog.csdn.net/ss19497/article/details/53730759</a> </p><h1 id="String、StringBuffer与StringBuilder之间区别"><a href="#String、StringBuffer与StringBuilder之间区别" class="headerlink" title="String、StringBuffer与StringBuilder之间区别"></a>String、StringBuffer与StringBuilder之间区别</h1><a id="more"></a><h2 id="运行速度"><a href="#运行速度" class="headerlink" title="运行速度"></a>运行速度</h2><p>StringBuilder &gt; StringBuffer &gt; String<br>String最慢的原因：</p><p>String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。以下面一段代码为例：</p><p>String str=”abc”;</p><p>System.out.println(str);</p><p>str=str+”de”;</p><p>System.out.println(str);</p><p>如果运行这段代码会发现先输出“abc”，然后又输出“abcde”，好像是str这个对象被更改了，其实，这只是一种假象罢了，JVM对于这几行代码是这样处理的，首先创建一个String对象str，并把“abc”赋值给str，然后在第三行中，其实JVM又创建了一个新的对象也名为str，然后再把原来的str的值和“de”加起来再赋值给新的str，而原来的str就会被JVM的垃圾回收机制（GC）给回收掉了，所以，str实际上并没有被更改，也就是前面说的String对象一旦创建之后就不可更改了。所以，Java中对String对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢。</p><p>而StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多。</p><p>另外，有时候我们会这样对字符串进行赋值</p><p>String str=”abc”+”de”;</p><p>StringBuilder stringBuilder=new StringBuilder().append(“abc”).append(“de”);</p><p>System.out.println(str);</p><p>System.out.println(stringBuilder.toString());</p><p>这样输出结果也是“abcde”和“abcde”，但是String的速度却比StringBuilder的反应速度要快很多，这是因为第1行中的操作和</p><p>String str=”abcde”;</p><p>是完全一样的，所以会很快，而如果写成下面这种形式</p><p>String str1=”abc”;</p><p>String str2=”de”;</p><p>String str=str1+str2;</p><p>那么JVM就会像上面说的那样，不断的创建、回收对象来进行这个操作了。速度就会很慢。</p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的</p><p>如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。所以如果要进行的操作是多线程的，那么就要使用StringBuffer，但是在单线程的情况下，还是建议使用速度比较快的StringBuilder。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>String：适用于少量的字符串操作的情况</p><p>StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况</p><p>StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况</p><h1 id="StringBuffer常用方法"><a href="#StringBuffer常用方法" class="headerlink" title="StringBuffer常用方法"></a>StringBuffer常用方法</h1><p>StringBuffer和StringBuider的方法差不多</p><h2 id="toString-String"><a href="#toString-String" class="headerlink" title="toString():String"></a>toString():String</h2><h2 id="append-String-：StringBuffer"><a href="#append-String-：StringBuffer" class="headerlink" title="append(String)：StringBuffer"></a>append(String)：StringBuffer</h2><p>追加内容到当前StringBuffer对象的末尾，类似于字符串的连接。调用该方法以后，StringBuffer对象的内容也发生改变;<br>例如：</p><p>StringBuffer sb = new StringBuffer(“abc”);<br>sb.append(true);<br>则对象sb的值将变成”abctrue”。</p><h2 id="insert-int-offset-String-s-：StringBuffer"><a href="#insert-int-offset-String-s-：StringBuffer" class="headerlink" title="insert(int offset, String s)：StringBuffer"></a>insert(int offset, String s)：StringBuffer</h2><p>StringBuffer对象中的相应索引后面插入内容，然后形成新的字符串<br>例如：</p><p>StringBuffer sb = new StringBuffer(“TestString”);<br>sb.insert(4,false);<br>该示例代码的作用是在对象sb的索引值4的位置插入false值，形成新的字符串，则执行以后对象sb的值是”TestfalseString”。</p><h2 id="reverse-：StringBuffer"><a href="#reverse-：StringBuffer" class="headerlink" title="reverse()：StringBuffer"></a>reverse()：StringBuffer</h2><p>将StringBuffer对象中的内容反转，然后形成新的字符串。<br>例如：</p><p>StringBuffer sb = new StringBuffer(“abc”);<br>sb.reverse();<br>经过反转以后，对象sb中的内容将变为”cba”。</p><h2 id="setCharAt-int-index-char-ch-void"><a href="#setCharAt-int-index-char-ch-void" class="headerlink" title="setCharAt(int index, char ch): void"></a>setCharAt(int index, char ch): void</h2><p>该方法的作用是修改对象中索引值为index位置的字符为新的字符ch。<br>例如：</p><p>StringBuffer sb = new StringBuffer(“abc”);<br>sb.setCharAt(1,’D’);<br>则对象sb的值将变成”aDc”。</p><h2 id="deleteCharAt-int-index-StringBuffer"><a href="#deleteCharAt-int-index-StringBuffer" class="headerlink" title="deleteCharAt(int index): StringBuffer"></a>deleteCharAt(int index): StringBuffer</h2><p>该方法的作用是删除指定位置的字符，然后将剩余的内容形成新的字符串。例如：</p><p>StringBuffer sb = new StringBuffer(“Test”);<br>sb. deleteCharAt(1);<br>该代码的作用删除字符串对象sb中索引值为1的字符，也就是删除第二个字符，剩余的内容组成一个新的字符串。所以对象sb的值变为”Tst”。</p><p>还存在一个功能类似的delete方法：</p><h2 id="delete-int-start-int-end-StringBuffer"><a href="#delete-int-start-int-end-StringBuffer" class="headerlink" title="delete(int start,int end): StringBuffer"></a>delete(int start,int end): StringBuffer</h2><p>该方法的作用是删除指定区间以内的所有字符，包含start，不包含end索引值的区间。例如：<br>StringBuffer sb = new StringBuffer(“TestString”);<br>sb. delete (1,4);<br>该代码的作用是删除索引值1(包括)到索引值4(不包括)之间的所有字符，剩余的字符形成新的字符串。则对象sb的值是”TString”。</p><h1 id="字符串题目（java）"><a href="#字符串题目（java）" class="headerlink" title="字符串题目（java）"></a>字符串题目（java）</h1><p>输入描述:<br>输入一个非空字符串<br>输出描述:<br>输出第一个只出现一次的字符，如果不存在输出-1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//1、</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        while (sc.hasNext()) &#123;</span><br><span class="line">            String str=sc.next();</span><br><span class="line">            int n=str.length();</span><br><span class="line">            for (int i=0;i&lt;n;i++)&#123;</span><br><span class="line">                 </span><br><span class="line">                char ch=str.charAt(i);</span><br><span class="line">                String s=ch+&quot;&quot;;</span><br><span class="line">                if ((n-str.replaceAll(s,&quot;&quot;).length())==1)&#123;</span><br><span class="line">                    System.out.println(str.charAt(i));</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//2、</span><br><span class="line">public class Main &#123;  </span><br><span class="line">   </span><br><span class="line">    public static void main(String[] args) &#123; </span><br><span class="line">        Scanner sc = new Scanner(System.in); </span><br><span class="line">        while(sc.hasNext())&#123;</span><br><span class="line">            String str = sc.nextLine();</span><br><span class="line">            char[] cs = str.toCharArray();</span><br><span class="line">            for(int i = 0; i &lt; cs.length; i++)&#123;</span><br><span class="line">                if(str.indexOf(cs[i]) == str.lastIndexOf(cs[i]))&#123;</span><br><span class="line">                    System.out.println(cs[i]);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sc.close(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>剑指offer笔记</title>
      <link href="/2018/08/26/%E5%89%91%E6%8C%87offer%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/08/26/%E5%89%91%E6%8C%87offer%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>面试题主页：<a href="http://zhedahht.blog.163.com/" target="_blank" rel="noopener">http://zhedahht.blog.163.com/</a><br><a id="more"></a></p><h2 id="Java内存的堆和栈"><a href="#Java内存的堆和栈" class="headerlink" title="Java内存的堆和栈"></a>Java内存的堆和栈</h2><ul><li>堆中存放对象 </li><li>栈中存放对象的引用</li></ul><h2 id="JVM内存区域的划分"><a href="#JVM内存区域的划分" class="headerlink" title="JVM内存区域的划分"></a>JVM内存区域的划分</h2><p>资料</p><ul><li><a href="https://www.cnblogs.com/cherryljr/p/6230380.html" target="_blank" rel="noopener">https://www.cnblogs.com/cherryljr/p/6230380.html</a></li><li><a href="http://blog.holten.site/2016/04/09/JVM-memory-area/" target="_blank" rel="noopener">http://blog.holten.site/2016/04/09/JVM-memory-area/</a><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3></li></ul><h2 id="参数的值传递与引用传递"><a href="#参数的值传递与引用传递" class="headerlink" title="参数的值传递与引用传递"></a>参数的值传递与引用传递</h2><p><a href="https://github.com/nnngu/LearningNotes/blob/master/Java%20Basis/007%20Java%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92.md" target="_blank" rel="noopener">https://github.com/nnngu/LearningNotes/blob/master/Java%20Basis/007%20Java%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92.md</a></p><ul><li>按值传递：值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。简单来说就是直接复制了一份数据过去，因为是直接复制，所以这种方式在传递时如果数据量非常大的话，运行效率自然就变低了，所以java在传递数据量很小的数据是值传递，比如java中的各种基本类型。</li><li>按引用传递：引用传递其实就弥补了上面说的不足，如果每次传参数的时候都复制一份的话，如果这个参数占用的内存空间太大的话，运行效率会很底下，所以引用传递就是直接把内存地址传过去，也就是说引用传递时，操作的其实都是源数据，这样的话修改有时候会冲突，记得用逻辑弥补下就好了，具体的数据类型就比较多了，比如Object，二维数组，List，Map等除了基本类型的参数都是引用传递。<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    private static void foo(int value) &#123;</span><br><span class="line">        value = 100;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int num=1;</span><br><span class="line">        foo(num);</span><br><span class="line">        System.out.print(&quot;num :&quot;+num);//num没有改变</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">输出：num :1</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li></ul><h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">static void foo(String text) &#123;</span><br><span class="line">        text = &quot;windows&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">public static void main(String[] args)&#123; </span><br><span class="line">String str=&quot;Hello World&quot;;</span><br><span class="line">        foo(str);</span><br><span class="line">        System.out.print(&quot;str :&quot;+str);//str没有变</span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">输出：str:Hello World</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">static void foo(StringBuilder builder) &#123;</span><br><span class="line">    builder.append(&quot;4&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">public static void main(String[] args)&#123; </span><br><span class="line">StringBuilder str = new StringBuilder(&quot;iphone&quot;);</span><br><span class="line">        foo(str);</span><br><span class="line">        System.out.print(&quot;str :&quot;+str);//str发生改变</span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">输出：str:iphone4</span><br><span class="line">*/ </span><br><span class="line">void foo(StringBuilder builder) &#123;</span><br><span class="line">    builder.append(&quot;4&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="什么是哈希表？"><a href="#什么是哈希表？" class="headerlink" title="什么是哈希表？"></a>什么是哈希表？</h3><p>数组和向量都可以存储对象，但对象的存储位置是随机的，也就是说对象本身与其存储位置之间没有必然的联系。当要查找一个对象时，只能以某种顺序（如顺序查找或二分查找）与各个元素进行比较，当数组或向量中的元素数量很多时，查找的效率会明显的降低。</p><p>一种有效的存储方式，是不与其他元素进行比较，一次存取便能得到所需要的记录。这就需要在对象的存储位置和对象的关键属性（设为 k）之间建立一个特定的对应关系（设为 f），使每个对象与一个唯一的存储位置相对应。在查找时，只要根据待查对象的关键属性 k 计算f(k)的值即可。如果此对象在集合中，则必定在存储位置 f(k)上，因此不需要与集合中的其他元素进行比较。称这种对应关系 f 为哈希（hash）方法，按照这种思想建立的表为哈希表。</p><h3 id="使用哈希表的例子"><a href="#使用哈希表的例子" class="headerlink" title="使用哈希表的例子"></a>使用哈希表的例子</h3><h4 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a>第一个只出现一次的字符</h4><p>描述：在字符串中找出第一个只出现一次的字符。如输入”abaccdeff”，则输出”b”;</p><p>思路：定义哈希表的key是字符，value是该字符出现的次数；则只需扫描两次字符串，第一次扫描时，将哈希表对应的键和值搞定，第二次扫描时，每扫描一个字符就可以在哈希表中得到次数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//1:</span><br><span class="line">public static int FirstNotRepeatingChar(String str) &#123;</span><br><span class="line"> int[] hash=new int[256];</span><br><span class="line"> int len=str.length();</span><br><span class="line"> for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line"> char temp=str.charAt(i);</span><br><span class="line"> //每个字母根据其ASCII码值作为数组下标对应该字符出现的次数</span><br><span class="line"> hash[temp]++;</span><br><span class="line"> &#125;</span><br><span class="line"> int i;</span><br><span class="line"> for(i=0;i&lt;len;i++)&#123;</span><br><span class="line"> char temp=str.charAt(i);</span><br><span class="line"> if(hash[temp]==1)</span><br><span class="line"> return i;</span><br><span class="line"> &#125;</span><br><span class="line">        return -1;</span><br><span class="line">&#125;</span><br><span class="line">//2</span><br><span class="line">public Character firstNotRepeating(String str)&#123;</span><br><span class="line">if(str == null)</span><br><span class="line">return null;</span><br><span class="line">char[] strChar = str.toCharArray();</span><br><span class="line">LinkedHashMap&lt;Character,Integer&gt; hash = new LinkedHashMap&lt;Character,Integer&gt;();</span><br><span class="line">for(char item:strChar)&#123;</span><br><span class="line">if(hash.containsKey(item))</span><br><span class="line">hash.put(item, hash.get(item)+1);</span><br><span class="line">else</span><br><span class="line">hash.put(item, 1);</span><br><span class="line">&#125;</span><br><span class="line">for(char key:hash.keySet())</span><br><span class="line">&#123;</span><br><span class="line">if(hash.get(key)== 1)</span><br><span class="line">return key;</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="关于数组的面试题"><a href="#关于数组的面试题" class="headerlink" title="关于数组的面试题"></a>关于数组的面试题</h2><h3 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h3><p>描述：在长度为n的数组里所有的数字都在0~n-1的范围内，数组中有这些数字是重复出现的，但是不知道有几个数字重复了，也不知道重复了几次，求找出任意一个重复的数字；</p><h4 id="用哈希表"><a href="#用哈希表" class="headerlink" title="用哈希表"></a>用哈希表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从头到尾扫描数组中的每一个数字，没扫描到一个数字的时候，都可以用O(1)的时间来判断哈希表中是否存在这个数字。如果没有这个数字，就将他放到哈希表中，反之就找到了一个数字，结束寻找；算法时间是O(n),还有个大小为O(n)的哈希表；</span><br></pre></td></tr></table></figure><h4 id="更有效的方法"><a href="#更有效的方法" class="headerlink" title="更有效的方法"></a>更有效的方法</h4><p>思路：假设数组为a,现在我们重排数组，当扫描到a[i]时，先判断(a[i]==i)?true:false;如果为true，则i+1,扫描下一个数，反之，假设a[i]=m,(m!=i),先比较a[m]= =a[i]?true:false,如果true,我们就找到了一个重复数字，反之，我们就交换这两个数字（相当于把m放到了属于他的位置）；接下来在继续重复这些步骤；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static boolean duplicate(int []num)&#123;</span><br><span class="line"></span><br><span class="line">        if(num==null||num.length&lt;=0) return false;</span><br><span class="line">        int len=num.length;</span><br><span class="line">        for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">            if(num[i]&lt;0||num[i]&gt;len-1)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">            while(num[i]!=i)&#123;</span><br><span class="line">                if(num[i]==num[num[i]])&#123;</span><br><span class="line">                    System.out.println(num[i]);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    int temp = num[num[i]];</span><br><span class="line">                    num[num[i]]=num[i];</span><br><span class="line">                    num[i] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="不修改数组找数组中重复的数字"><a href="#不修改数组找数组中重复的数字" class="headerlink" title="不修改数组找数组中重复的数字"></a>不修改数组找数组中重复的数字</h4><h3 id="旋转数组中的最小数字"><a href="#旋转数组中的最小数字" class="headerlink" title="旋转数组中的最小数字"></a>旋转数组中的最小数字</h3><p>描述：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。</p><p>思路：二分法；我们用两个指针分别指向数组的第一个元素和最后一个元素。按照旋转规则，第一个元素应该大于等于最后一个元素。接着可以找到数组中间的元素。如果中间元素位于前面的递增数组，则它应该大于等于第一个指针指向的元素，此时我们要找到的最小元素肯定应该位于该中间元素的后面。这样我们把第一个指针指向中间元素，从而缩小查找范围。注意，移动之后的第一个指针仍然是位于前面的递增数组中。<br>同理，如果中间元素位于后面的递增子数组，那么它应该小于等于第二个指针指向的元素。此时最小元素应该位于中间元素的前面或者就是此中间元素。我们把第二个指针指向中间元素，从而缩小查找范围。注意，移动之后的第二个指针仍然是位于后面的递增数组中。<br>     按照上述思路，第一个指针总是指向前面的递增数组元素，而第二个指针总是指向后面的递增数组元素。最终第一个指针将指向前面的子数组的最后一个元素，第二个指针将指向后面的子数组的第一个元素，即二者最后指向相邻的元素，且第二个指针指向的刚好是最小的元素——循环结束条件。<br>     但是如果第一个指针指向的元素、第二个指针指向的元素和中间元素相同，则无法判断中间元素是属于哪个子数组，也就无法移动两个指针来缩小查找范围，此时还是要用顺序查找的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private static int solution(int[] array)&#123;</span><br><span class="line">        int low=0;</span><br><span class="line">        int high=array.length-1;</span><br><span class="line">        int middle=0;</span><br><span class="line">        while(high!=(low+1))&#123;</span><br><span class="line">            middle=(low+high)/2;</span><br><span class="line">            if(array[low]==array[middle]&amp;&amp;array[middle]==array[high])</span><br><span class="line">                return findMinInOrder(array,low,high);</span><br><span class="line"></span><br><span class="line">            if(array[middle]&gt;=array[low])&#123;</span><br><span class="line">                low=middle;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                high=middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return array[high];</span><br><span class="line">    &#125;</span><br><span class="line">    private static int findMinInOrder(int[] array,int indexLow,int indexHigh)&#123;</span><br><span class="line">        int result=array[indexLow];</span><br><span class="line">        for(int i=indexLow+1;i&lt;indexHigh;i++)&#123;</span><br><span class="line">                if(array[i]&lt;result)</span><br><span class="line">                        result=array[i];</span><br><span class="line">            &#125;</span><br><span class="line">                 return result;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h3 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h3><p>描述：在一个二维数组中，每一行都是按照自从左到右递增的顺序，每一列都是按照从上到下的递增顺序，要求输入一个整数判断该整数是否在这个二维数组中；<br> 思路：假设数组为a[n][m],整数为k ，令row=0,col=m-1,我们先取该数组中的a[row][col]与k作比较，</p><ul><li>如果a[row][col]==k, 输出true;</li><li>如果a[row][col]&lt;k,说明在第row行的最大值都比k小，则淘汰第row行；比较a[row+1][col]与k的关系；</li><li>如果a[row] [col]&gt;k,说明第col列的最小值都比k大，则淘汰第col列；比较a[row][col-1];<br>重复以上步骤直到row= =n-1 || col==0</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private static boolean find(int[][]matrix,int x)&#123;</span><br><span class="line">       int rowIndex=0;</span><br><span class="line">       int columnIndex=matrix.length-1;</span><br><span class="line">       while(rowIndex&lt;matrix.length &amp;&amp; columnIndex&gt;=0)&#123;</span><br><span class="line">           if(matrix[rowIndex][columnIndex]== x)&#123;</span><br><span class="line">               return true;</span><br><span class="line">           &#125;else if(matrix[rowIndex][columnIndex]&lt;x)&#123;</span><br><span class="line">               rowIndex++;</span><br><span class="line">           &#125;else &#123;</span><br><span class="line">               columnIndex--;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>经验：当要处理的数组是有序数组时，一般使用二分法；</p><h3 id="在排序数组中查找数字"><a href="#在排序数组中查找数字" class="headerlink" title="在排序数组中查找数字"></a>在排序数组中查找数字</h3><h4 id="数字在排序数组中出现的次数"><a href="#数字在排序数组中出现的次数" class="headerlink" title="数字在排序数组中出现的次数"></a>数字在排序数组中出现的次数</h4><p>思路：利用二分法直接查找这个数字k的第一次和最后一次出现的位置<br>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private static int getFirstK(int[] array,int k)&#123;</span><br><span class="line">        int start=0;</span><br><span class="line">        int end=array.length-1;</span><br><span class="line">        int middle=(start+end)/2 ;</span><br><span class="line">        while(start&lt;=end)&#123;</span><br><span class="line">            if(array[middle]&gt;k)&#123;</span><br><span class="line">                end=middle-1;</span><br><span class="line">            &#125;else if(array[middle]&lt;k)&#123;</span><br><span class="line">                start=middle+1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                while (array[middle]==k)&#123;</span><br><span class="line">                    middle--;</span><br><span class="line">                &#125;</span><br><span class="line">                return middle+1;</span><br><span class="line">            &#125;</span><br><span class="line">            middle=(start+end)/2;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h4 id="0-n中缺失的数字"><a href="#0-n中缺失的数字" class="headerlink" title="0~n中缺失的数字"></a>0~n中缺失的数字</h4><p>描述： 一个长度为n递增排序的数组，数组上的数字的范围是0 ~ n,并且数组上的数字是唯一的，请找出这(n+1)个数字中不在数组上的数字；</p><h5 id="解法一-O-n"><a href="#解法一-O-n" class="headerlink" title="解法一: O(n)"></a>解法一: O(n)</h5><p>用公式求0~n这n+1个数的和，记为s1,接着求该数组上的所有数字的和，记为s2,则缺少的数字就是s1-s2;</p><h5 id="解法二：O-log2-n"><a href="#解法二：O-log2-n" class="headerlink" title="解法二：O(log2(n))"></a>解法二：O(log2(n))</h5><p>该数组的特殊性：a[i]=i;<br>等价与找出在这个数组中第一个a[i]!=i数字；<br>用二分法查找<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private static int getLost(int []a)&#123;</span><br><span class="line">        int start=0;</span><br><span class="line">        int end=a.length-1;</span><br><span class="line">        int middle=(start+end)/2;</span><br><span class="line">        while(start&lt;=end)&#123;</span><br><span class="line">            if(a[middle]==middle)&#123;</span><br><span class="line">                start=middle+1;</span><br><span class="line"></span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(a[middle-1]==middle-1)&#123;</span><br><span class="line">                    return middle;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    end=middle+1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            middle=(start+end)/2;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h4 id="数值与下标相等的元素"><a href="#数值与下标相等的元素" class="headerlink" title="数值与下标相等的元素"></a>数值与下标相等的元素</h4><p>二分法：</p><ul><li>假设到达第i个数字，如果a[i]==i,则找到一个元素</li><li>如果a[i]=m且m!=i,则<ul><li>a[i]&gt;i :根据数组递增的特性可知：a[i]以后的元素的值至少每个比前面大1，同时它们的下标每次也是增加1，从而右边的这些元素的值都大于它们的下标，因此需要继续在左边寻找</li><li>a[i]&lt;i:a[i]左边的那些元素的值也都小于它们的下标，因此需要继续在右边寻找<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private static int getNumberSameIndex(int []a)&#123;</span><br><span class="line">        int start=0;</span><br><span class="line">        int end=a.length-1;</span><br><span class="line"></span><br><span class="line">        while(start&lt;=end)&#123;</span><br><span class="line">            int midlle=(start+end)/2;</span><br><span class="line">            if(a[midlle]==midlle)&#123;</span><br><span class="line">               return midlle;</span><br><span class="line"></span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(a[midlle]&gt;midlle)&#123;</span><br><span class="line">                    end=midlle-1;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    start=midlle+1;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="数组中数字出现的次数"><a href="#数组中数字出现的次数" class="headerlink" title="数组中数字出现的次数"></a>数组中数字出现的次数</h3><h4 id="数组中只出现一次的两个数字"><a href="#数组中只出现一次的两个数字" class="headerlink" title="数组中只出现一次的两个数字"></a>数组中只出现一次的两个数字</h4><p>描述：一个整形数组里除了两个数字之外，其他数字都出现了两次，求输出这两个数字；要求时间复杂度为O(n),空间复杂度为O(1);</p><p>思路：如果这个数组中只有一个数没有出现两次，则使用任何两个相同的数字的异或为0这个性质，从头到尾异或数组中的每个数字，则最终的结果就是只出现一次的数字；<br>因此，解决这个问题的办法就是将这个 数组分为两个数组，每个数组只有一个只出现一次的数字！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private static int[] FindNumsApperaOnce(int []data)&#123;</span><br><span class="line">       int result[]=new int[]&#123;0,0&#125;;</span><br><span class="line">       if(data==null||data.length&lt;2) return null;</span><br><span class="line">       int bitResult=0;</span><br><span class="line">       //对所有的数字求异或运算</span><br><span class="line">       for(int i=0;i&lt;data.length;i++)&#123;</span><br><span class="line">           bitResult^=data[i];</span><br><span class="line">       &#125;</span><br><span class="line">       int index=FingFirstBitIs1(bitResult);</span><br><span class="line">       for(int i=0;i&lt;data.length;i++)&#123;</span><br><span class="line">           if(isBit1(data[i],index))&#123;</span><br><span class="line">               result[0]^=data[i];</span><br><span class="line">           &#125;else &#123;</span><br><span class="line">               result[1]^=data[i];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br><span class="line">   private static int FingFirstBitIs1(int num)&#123;</span><br><span class="line">       int index=0;</span><br><span class="line">       while((num&amp;1)==0&amp;&amp;index&lt;32)&#123;</span><br><span class="line">           num=num&gt;&gt;1;</span><br><span class="line">           index++;</span><br><span class="line">       &#125;</span><br><span class="line">       return index;</span><br><span class="line">   &#125;</span><br><span class="line">   /*</span><br><span class="line">   用于检测某个数的第index位是否为1；</span><br><span class="line">   */</span><br><span class="line">   private static boolean isBit1(int target, int index)&#123;</span><br><span class="line">       return ((target &gt;&gt; index) &amp; 1) == 1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h4 id="数组中唯一只出现一次的数字"><a href="#数组中唯一只出现一次的数字" class="headerlink" title="数组中唯一只出现一次的数字"></a>数组中唯一只出现一次的数字</h4><p>描述：一个数组中除一个数字只出现一次外，其他数字都出现了三次，求找出这个数；<br> 思路：如果一个数字出现三次，那么他的二进制表示的每一位（0,1）都出现了三次，那么每一位都会被3整除，因此，将所有的数字的二进制的每一位做加法，如果某一位能被3整除，那么所求的数的该位就为0，否则为1；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private static int find(int []nums)throws Exception&#123;</span><br><span class="line">        int len = nums.length;</span><br><span class="line">        int[] bits = new int[32];</span><br><span class="line">        for(int i = 0 ; i &lt; len; i++)</span><br><span class="line">            for(int j = 0; j &lt; 32; j++)</span><br><span class="line">                bits[j] += ((nums[i]&gt;&gt;j)&amp;1);</span><br><span class="line"></span><br><span class="line">        int result = 0;</span><br><span class="line">        for(int i = 0 ; i &lt; 32; i++)&#123;</span><br><span class="line">            if(bits[i] % 3 == 1) result += 1 &lt;&lt; i;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="和为s的数字"><a href="#和为s的数字" class="headerlink" title="和为s的数字"></a>和为s的数字</h3><p>描述：输入一个递增的数组和一个数字s，在数组中查找任意一对数使他们的和为s；</p><p>思路：使用两个指针start、end分别指向数组的前面和后面两个数，当这两个数的和小于s时，start向后一个位置；当这两个数的和大于s时，end向前移动一个位置；直到找到这两个数或者start==end；时间复杂度为O(n)；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private static int[] find(int [] data,int s)&#123;</span><br><span class="line">        int start=0,end=data.length-1;</span><br><span class="line">        if(data==null||data.length&lt;2) return null;</span><br><span class="line">        int[] result=null;</span><br><span class="line">        while(start&lt;end)&#123;</span><br><span class="line">            int a=data[start],b=data[end];</span><br><span class="line">            if(a+b&gt;s)&#123;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;else if(a+b&lt;s) &#123;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                result=new int[]&#123;a,b&#125;;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="和为s的连续正数序列"><a href="#和为s的连续正数序列" class="headerlink" title="和为s的连续正数序列"></a>和为s的连续正数序列</h3><p>描述： 输入一个正数s,打印出所有和为s的连续正数序列（至少含有两个数）<br>思路：由于序列是连续的，所以我们可以用两个指针small和big分别指向序列的最小值和最大值，比如序列{2,3,4,5}，此时small指向2，big指向5；当序列和小于s，时，我们可以增大big使得序列个数变多，此时序列变为{2,3,4,5,6}，big指向6；反之则增大small使得序列个数变少，此时序列为{3,4,5}；<br>当找到一个序列满足条件时，再增加big，重复之前的操作；因为序列要求要有两个数，我们一直增加small直到等于s/2为止；</p><p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private static ArrayList&lt;ArrayList&lt;Integer&gt;&gt; find(int s)&#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result=new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; list;</span><br><span class="line">        if(s&lt;3) return null;</span><br><span class="line">        int small=1,big=2;</span><br><span class="line">        while (small&lt;=s/2)&#123;</span><br><span class="line">            if(sum(small,big)==s)&#123;</span><br><span class="line">                list=getList(small,big);</span><br><span class="line">                result.add(list);</span><br><span class="line">                big++;</span><br><span class="line">            &#125;else if(sum(small,big)&gt;s)&#123;</span><br><span class="line">                small++;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                big++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    private  static int sum(int small,int big)&#123;</span><br><span class="line">        int sum=0;</span><br><span class="line">        while (small&lt;=big)&#123;</span><br><span class="line">            sum+=small;</span><br><span class="line">            small++;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">    private  static ArrayList&lt;Integer&gt; getList(int small,int big)&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list=new ArrayList&lt;&gt;();</span><br><span class="line">        if(small&gt;=big) return null;</span><br><span class="line">        while(small&lt;=big)&#123;</span><br><span class="line">            list.add(small);</span><br><span class="line">            small++;</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>以下代码在求和时减少了很多不必要的运算<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(int sum)</span><br><span class="line">    &#123;</span><br><span class="line">  </span><br><span class="line">  ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listall = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">  if(sum &lt; 3)</span><br><span class="line">  &#123;</span><br><span class="line">  return listall; //因为至少要包括两个数，要求的是正整数序列，那么最小的和为3  </span><br><span class="line">  &#125;</span><br><span class="line">  int small = 1;//用来记录正整数序列中最小的数，</span><br><span class="line">  int big = 2;//用来记录正整数序列中最大的数</span><br><span class="line">  int mid = (sum + 1)/2;//序列之和为sum的数至少包括两个数，所以small&lt;mid</span><br><span class="line">  int cursum = small + big;//当前序列总和</span><br><span class="line">  while(small &lt; mid)</span><br><span class="line">  &#123;  </span><br><span class="line">  //当前的序列和大于sum</span><br><span class="line">  while(cursum &gt; sum &amp;&amp; small &lt; mid)</span><br><span class="line">  &#123;</span><br><span class="line">  cursum = cursum-small;</span><br><span class="line">  small++;</span><br><span class="line">  &#125;</span><br><span class="line">  //当前序列和为sum了，则将这些数加入到list中</span><br><span class="line">  if(cursum == sum)</span><br><span class="line">  &#123;</span><br><span class="line">  ArrayList&lt;Integer&gt; listsum = new ArrayList&lt;Integer&gt;();</span><br><span class="line">  add(listsum,small,big);</span><br><span class="line">  listall.add(listsum);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  //当前的序列和小于sum</span><br><span class="line">  big++;</span><br><span class="line">  cursum = cursum+big;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  return listall;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> private static void add(ArrayList&lt;Integer&gt; list,int small,int big)</span><br><span class="line"> &#123;</span><br><span class="line"> for (int i = small; i &lt;= big; i++)</span><br><span class="line">&#123;</span><br><span class="line">list.add(i);</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h3><p>描述：输入一个人链表的头结点，从尾到头打印链表的每个值<br>思路：利用栈，从头结点开始依次将节点压入栈中，再将栈中的节点依次弹出来；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//利用递归</span><br><span class="line">private void print(ListNode  head)&#123;</span><br><span class="line">if(head!=null)&#123;</span><br><span class="line">if(head.next!=null)</span><br><span class="line">print(head.next);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(head.val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="那些关于二叉树的事儿"><a href="#那些关于二叉树的事儿" class="headerlink" title="那些关于二叉树的事儿"></a>那些关于二叉树的事儿</h2><p>二叉树： 每个节点最多只有两个子节点；<br>二叉搜索树：左节点小于右节点，中序遍历的结果是一个递增序列；<br>完全二叉树: 只有最下面两层的节点的度可以小于2，并且最下一层的叶子节点集中在靠左的位置；<br>前序遍历：根，左，右<br>中序遍历：左，根，右<br>后序遍历：左，右，根<br>宽度优先遍历：从第一层节点开始一层一层访问，同一层中从左到右依次访问<br>红黑树：<br>堆（最大堆和最小堆）：一个大小为n的堆是一个含有n个节点的完全二叉树，如果树中节点的值大于或等于父节点的值，则为最小堆，即最小堆的根节点（堆顶）是最小的；</p><h3 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h3><p>描述：输入某二叉树的前序遍历和中序遍历结果，要求重建该二叉树；<br><img src="/2018/08/26/剑指offer笔记/重建的二叉树.jpg"><br><img src="/2018/08/26/剑指offer笔记/分析.jpg"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode &#123;</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(int x) &#123;</span><br><span class="line">            this.val = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">     * 给定二叉树的前序遍历和中序遍历，重构二叉树。假设前序遍历和中序遍历都没有重复的数</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param pre  前序遍历</span><br><span class="line">     * @param in    中序遍历</span><br><span class="line">     * @return        二叉树根节点</span><br><span class="line">     */</span><br><span class="line">    public TreeNode reConstructBinaryTree(int[] pre,int[] in) &#123;</span><br><span class="line">        /*</span><br><span class="line">         * 输入合法性判断， 不能为空，先序和后序长度要一致</span><br><span class="line">         */</span><br><span class="line">        if(pre == null || in == null || pre.length != in.length)</span><br><span class="line">            return null;</span><br><span class="line"></span><br><span class="line">        return construct(pre, 0, pre.length-1, in, 0, in.length-1);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param pre    前序遍历</span><br><span class="line">     * @param ps    前序遍历的开始位置</span><br><span class="line">     * @param pe    前序遍历的结束位置</span><br><span class="line">     * @param in    中序遍历</span><br><span class="line">     * @param is    中序遍历的开始位置</span><br><span class="line">     * @param ie    中序遍历的结束位置</span><br><span class="line">     * @return        数的根节点</span><br><span class="line">     */</span><br><span class="line">    private TreeNode construct(int[] pre, int ps, int pe, int[] in, int is, int ie) &#123;</span><br><span class="line">        if(ps &gt; pe) return null;</span><br><span class="line"></span><br><span class="line">        // 取前序遍历的第一个数字就是根节点</span><br><span class="line">        int value = pre[ps];</span><br><span class="line">        // 在中序遍历中中寻找根节点</span><br><span class="line">        int index =is;</span><br><span class="line">        while(index &lt;= ie &amp;&amp; value != in[index]) &#123;</span><br><span class="line">            index ++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果在整个中序遍历的数组中没有找到，说明输入的参数是不合法的，抛出异常</span><br><span class="line">        if(index &gt; ie)</span><br><span class="line">            throw new RuntimeException(&quot;Invalid Iuput!&quot;);</span><br><span class="line"></span><br><span class="line">        // 创建当前根节点，并为根节点赋值</span><br><span class="line">        TreeNode node = new TreeNode(value);</span><br><span class="line">        // 递归调用构建当前节点的左子树</span><br><span class="line"></span><br><span class="line">        node.left = construct(pre, ps+1, ps+index-is, in, is, index-1);</span><br><span class="line">        // 递归调用构建当前节点的右子树</span><br><span class="line">        node.right = construct(pre, ps+index-is+1, pe, in, index+1, ie);</span><br><span class="line"></span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private void printTree(TreeNode root) &#123;</span><br><span class="line">        if(root != null) &#123;</span><br><span class="line">            printTree(root.left);</span><br><span class="line">            System.out.print(root.val + &quot; &quot;);</span><br><span class="line">            printTree(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="二叉树的下一个节点"><a href="#二叉树的下一个节点" class="headerlink" title="二叉树的下一个节点"></a>二叉树的下一个节点</h3><p>描述：给定一棵二叉树和其中的一个节点，要求按照中序遍历的顺序输出该节点的下一个节点；树中的结点不仅包含左右子结点，同时包含指向父结点的指针。<br>思路：</p><ul><li>如果该节点有右子树，那中序遍历的下一个节点就是它的右子树的最左节点</li><li>如果该节点没有右子树，则找第一个当前节点是父节点左孩子的节点<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class TreeLinkNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeLinkNode left = null;</span><br><span class="line">    TreeLinkNode right = null;</span><br><span class="line">    TreeLinkNode parent = null;</span><br><span class="line">    </span><br><span class="line">    TreeLinkNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeLinkNode(int val,TreeLinkNode parent) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">        this.parent=parent;</span><br><span class="line">    &#125;</span><br><span class="line">    public void set(TreeLinkNode left,TreeLinkNode right)&#123;</span><br><span class="line">        this.left=left;</span><br><span class="line">        this.right=right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class Problem8 &#123;</span><br><span class="line">    public static TreeLinkNode GetNext(TreeLinkNode node) &#123;</span><br><span class="line">        if(node==null) return null;</span><br><span class="line">        if(node.right!=null)&#123;    //如果有右子树，则找右子树的最左节点</span><br><span class="line">            node = node.right;</span><br><span class="line">            while(node.left!=null) node = node.left;</span><br><span class="line">            System.out.print(node.val);</span><br><span class="line">            return node;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            while(node.parent!=null)&#123; //没右子树，则找第一个当前节点是父节点左孩子的节点</span><br><span class="line">                if(node.parent.left==node) &#123;</span><br><span class="line">                    System.out.print(node.parent.val);</span><br><span class="line">                    return node.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="有序二叉树中，求两个节点的最低公共祖先"><a href="#有序二叉树中，求两个节点的最低公共祖先" class="headerlink" title="有序二叉树中，求两个节点的最低公共祖先"></a>有序二叉树中，求两个节点的最低公共祖先</h3><p>思路：从根节点出发遍历树，如果当前节点比两个节点的值大，则下一步遍历当前节点的左子树，反之则遍历当前节点的右子树；直到当前节点的值处于这两个节点值的中间为止，此时当前节点就是所求； </p><h3 id="二叉搜索树的从小到大的第k个节点"><a href="#二叉搜索树的从小到大的第k个节点" class="headerlink" title="二叉搜索树的从小到大的第k个节点"></a>二叉搜索树的从小到大的第k个节点</h3><p>思路：中序遍历该树即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static ArrayList&lt;TreeNode&gt; arr = new ArrayList&lt;TreeNode&gt;();</span><br><span class="line">   private static TreeNode getKNode(TreeNode root,int k)&#123;</span><br><span class="line">      if(root==null||k==0) return null;</span><br><span class="line">      inOrder(root);</span><br><span class="line">      TreeNode result=root;</span><br><span class="line">      if(k&lt;=arr.size())&#123;</span><br><span class="line">          result = arr.get(k-1);</span><br><span class="line">      &#125;else &#123;</span><br><span class="line">          return null;</span><br><span class="line">      &#125;</span><br><span class="line">      return result;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   private static void inOrder(TreeNode root)&#123;</span><br><span class="line">       if(root==null) return;</span><br><span class="line">       if(root.left!=null)</span><br><span class="line">           inOrder(root.left);</span><br><span class="line">       arr.add(root);</span><br><span class="line">       if(root.right!=null)&#123;</span><br><span class="line">           inOrder(root.right);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h3 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static int getDept(TreeNode root)&#123;</span><br><span class="line">        if(root==null) return 0;</span><br><span class="line">        int l=getDept(root.left)+1;</span><br><span class="line">        int r=getDept(root.right)+1;</span><br><span class="line">        return (l&gt;r)?l:r;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="判断某棵树是否是平衡二叉树"><a href="#判断某棵树是否是平衡二叉树" class="headerlink" title="判断某棵树是否是平衡二叉树"></a>判断某棵树是否是平衡二叉树</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static boolean isBalanceTree(TreeNode root)&#123;</span><br><span class="line">    if(root==null)</span><br><span class="line">        return true;</span><br><span class="line">    int l=getDept(root.left);</span><br><span class="line">    int r=getDept(root.right);</span><br><span class="line">    if(l-r&gt;1||r-l&gt;1)</span><br><span class="line">        return false;</span><br><span class="line">    return isBalanceTree(root.left)&amp;&amp;isBalanceTree(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h3><p><a href="https://blog.csdn.net/d12345678a/article/details/54178612" target="_blank" rel="noopener">https://blog.csdn.net/d12345678a/article/details/54178612</a></p><ul><li>序列化：根据前序遍历的顺序，遍历二叉树絮遇到的空左子树或者右子树时，用”#”替代；节点间用”,”分隔开；</li><li>反序列化：输入序列化的得到的字符串，还原二叉树；</li></ul><h2 id="递归思想与回溯法"><a href="#递归思想与回溯法" class="headerlink" title="递归思想与回溯法"></a>递归思想与回溯法</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h4 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h4><h5 id="不好的方法（递归）"><a href="#不好的方法（递归）" class="headerlink" title="不好的方法（递归）"></a>不好的方法（递归）</h5><p>此方法重复求了很多节点，时间复杂度大<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static int Fibonacci(int n)&#123;</span><br><span class="line">if(n&lt;=0) return 0;</span><br><span class="line">if(n==1) return 1; </span><br><span class="line">return  Fibonacci(n-1)+ Fibonacci(n-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="利用循环实现"><a href="#利用循环实现" class="headerlink" title="利用循环实现"></a>利用循环实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private static int Fibonacci(int n)&#123;</span><br><span class="line">int[] result=&#123;0,1&#125;//保存n=0,1的值</span><br><span class="line">if(n&lt;2) return result[n];</span><br><span class="line">int f0=0;</span><br><span class="line">int f1=1;</span><br><span class="line">int fn=0;</span><br><span class="line">for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">       fn=f0+f1;</span><br><span class="line">       f0=f1;</span><br><span class="line">       f1=fn;</span><br><span class="line">    &#125;</span><br><span class="line">    return fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="斐波那契数列的应用"><a href="#斐波那契数列的应用" class="headerlink" title="斐波那契数列的应用"></a>斐波那契数列的应用</h5><p>描述：一只青蛙一次可以跳上1级台阶，也可以跳上两节台阶，求该青蛙跳上n级台阶一共有多少中跳法；<br>思路：如果只有1级台阶，那只有f(1)=1种跳法；如果有2级台阶，就有f(2)=2种跳法；<br>当有n级台阶时，青蛙第一次跳的选择有两种：一是第一次只跳1级，此时的跳法数等于后面n-1级台阶的跳法数；二是第一次跳2级，此时的跳法数等于后面n-2级台阶的跳法数；所以f(n)=f(n-1)+f(n-2);</p><p>类似的题目还有很多，可以用数学归纳法进行总结；</p><h4 id="字符串的全排列"><a href="#字符串的全排列" class="headerlink" title="字符串的全排列"></a>字符串的全排列</h4><p>问题描述：输入一个字符串，打印出该字符串的所有排列。例如，输入字符串”abc”，则输出有字符’a’,’b’,’c’所能排列出来的所有字符串”abc”,”acb”,”bac”,”bca”,”cab”,”cba”；</p><p>递归实现:将字符串看成两部分，第一部分是第一个字符，另一部分是之后的所有字符，之后将第一部分的字符与第二部分的字符逐个交换位置；</p><p>代码：<a href="https://www.cnblogs.com/liuzhen1995/p/6395361.html" target="_blank" rel="noopener">https://www.cnblogs.com/liuzhen1995/p/6395361.html</a></p><h4 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h4><p>问题描述：在8X8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。</p><p>思路：初始化一个数组array{0,1,2,3,4,5,6,7,}，对这个字符串进行全排列，array[i]表示在第i行第array[i]列上有一个皇后，因为i是唯一的，所以这个皇后一定不是在同一行上也不在同一列上，所以只需判断皇后是否在同一对角线上就可以了；<br>即判断是否有array[i]-array[j]==i-j 或者 array[i]-array[j]=j-i;<br><a href="https://blog.csdn.net/zhong317/article/details/4586131" target="_blank" rel="noopener">https://blog.csdn.net/zhong317/article/details/4586131</a></p><h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><p>在包含问题的所有可能解空间中，从根节点处罚，按照深度优先策略进行搜索，对于解空间树的某个节点，如果该节点满足问题的约束条件，则进入该子树继续进行搜索，否则将以该节点为根节点进行剪枝。回溯法常常可以避免搜索所有可能解，适用于组合较数较大的问题。</p><h4 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h4><p>描述：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。<br>例如<br>a b c e<br>s f c s<br>a d e e<br>{ a b c e s f c s a d e e }矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p><p>思路：首先，在矩阵中任选一个格子作为路径的起点。假设矩阵中某个格子的字符为ch，并且这个格子将对应于在路径上的第i个字符。假设路径上的第i个字符不是ch。那么这个格子不可能处在路径上的第i个位置。假设路径上的第i个字符正好是ch。那么往相邻的格子寻找路径上的第i+1个字符。除在矩阵边界上的格子之外，其它格子都有4个相邻的格子。反复这个过程知道路径上的全部字符都在矩阵中找到相应的位置。</p><p>　　因为回朔法的递归特性，路径能够被开成一个栈。当在矩阵中定位了路径中前n个字符的位置之后。在与第n个字符相应的格子的周围都没有找到第n+1个字符。这个时候仅仅要在路径上回到第n-1个字符。又一次定位第n个字符。</p><p>　　因为路径不能反复进入矩阵的格子。还须要定义和字符矩阵大小一样的布尔值矩阵，用来标识路径是否已经进入每个格子。 　　<br>    当矩阵中坐标为（row,col）的格子和路径字符串中下标为pathLength的字符一样时。从4个相邻的格子(row,col-1),(row-1,col),(row,col+1)以及(row+1,col)中去定位路径字符串中下标为pathLength+1的字符。</p><p>　　假设4个相邻的格子都没有匹配字符串中下标为pathLength+1的字符，表明当前路径字符串中下标为pathLength的字符在矩阵中的定位不对，我们须要回到前一个字符(pathLength-1)，然后又一次定位。<br>　　一直反复这个过程，直到路径字符串上全部字符都在矩阵中找到合适的位置；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static boolean hasPath(char[] matrix, int rows, int cols, char[] str) &#123;</span><br><span class="line">        boolean flag[] = new boolean[matrix.length];</span><br><span class="line">        for (int i = 0; i &lt; rows; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; cols; j++) &#123;</span><br><span class="line">                if (helper(matrix, rows, cols, i, j, str, 0, flag))</span><br><span class="line">                    return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">/*</span><br><span class="line">k 记录str中的字符的位置</span><br><span class="line"> */</span><br><span class="line">    private static boolean helper(char[] matrix, int rows, int cols, int i, int j, char[] str, int k, boolean[] flag) &#123;</span><br><span class="line">        int index = i * cols + j;</span><br><span class="line">        if (i &lt; 0 || i &gt;= rows || j &lt; 0 || j &gt;= cols || matrix[index] != str[k] || flag[index])</span><br><span class="line">            return false;</span><br><span class="line">        if(k == str.length - 1) return true;</span><br><span class="line">        flag[index] = true;</span><br><span class="line">        if (       helper(matrix, rows, cols, i - 1, j, str, k + 1, flag)</span><br><span class="line">                || helper(matrix, rows, cols, i + 1, j, str, k + 1, flag)</span><br><span class="line">                || helper(matrix, rows, cols, i, j - 1, str, k + 1, flag)</span><br><span class="line">                || helper(matrix, rows, cols, i, j + 1, str, k + 1, flag)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        flag[index] = false;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h4 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h4><p>描述：地上有个m行n列的方格。一个机器人从坐标(0,0)的格子开始移动，它每一次可以向左、右、上、下移动一格，但不能进入行坐标和列坐标的数位之和大于k的格子。<br>例如我们输入的K=4，则机器人能够到达的格子数为：15。<br><img src="/2018/08/26/剑指offer笔记/机器人路径.jpg"><br>思路：机器人从 [0,0] 格子开始移动，当它移动到下一个格子的时候，我们通过格子的数位来判断该机器人是否有权利进入，如果可以，格子数+1，我们再判断[i-1,j],[i,j-1][i+1,j],[i,j+1]这相邻的四个格子能否进入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private  static int movingCount(int threshold,int rows,int cols)&#123;</span><br><span class="line">        if(threshold&lt;0||rows&lt;0||cols&lt;0)</span><br><span class="line">            return 0;</span><br><span class="line">        boolean[] visited=new boolean[rows * cols];</span><br><span class="line">        int count = movingCountCore(threshold, rows, cols, 0, 0, visited);</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">    private  static int movingCountCore(int threshold,int rows,int cols,int row,int col,boolean[] visited)&#123;</span><br><span class="line">        int count= 0;</span><br><span class="line">        if(check(threshold, rows, cols, row, col, visited))&#123;</span><br><span class="line"></span><br><span class="line">            visited[row*cols+col]=true;</span><br><span class="line">            count=1 + movingCountCore(threshold, rows, cols, row + 1, col, visited)</span><br><span class="line">                    + movingCountCore(threshold, rows, cols, row - 1, col, visited)</span><br><span class="line">                    + movingCountCore(threshold, rows, cols, row, col + 1, visited)</span><br><span class="line">                    + movingCountCore(threshold, rows, cols, row, col - 1, visited);</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">    private static boolean check(int threshold, int rows, int cols, int row, int col, boolean[] visited)&#123;</span><br><span class="line">        if (row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; cols &amp;&amp; visited[row * cols + col] == false</span><br><span class="line">                &amp;&amp; getDigitSum(col) + getDigitSum(row) &lt;= threshold)</span><br><span class="line">            return true;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    private static int getDigitSum(int col) &#123;</span><br><span class="line">        int sum=0;</span><br><span class="line">        while(col!=0)&#123;</span><br><span class="line">            sum+=col%10;</span><br><span class="line">            col=col/10;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h4 id="回溯法求解图的着色问题"><a href="#回溯法求解图的着色问题" class="headerlink" title="回溯法求解图的着色问题"></a>回溯法求解图的着色问题</h4><p><a href="https://blog.csdn.net/lican19911221/article/details/26264471" target="_blank" rel="noopener">https://blog.csdn.net/lican19911221/article/details/26264471</a></p><h2 id="Java-栈与队列"><a href="#Java-栈与队列" class="headerlink" title="Java 栈与队列"></a>Java 栈与队列</h2><p>资料：<a href="https://blog.csdn.net/ls5718/article/details/51700503" target="_blank" rel="noopener">https://blog.csdn.net/ls5718/article/details/51700503</a></p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>特点：先进后出</p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>特点：先进先出</p><p>队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作。<br>LinkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用。</p><ul><li>offer(); 添加元素</li><li>poll(); 返回第一个元素，并在队列中删除</li><li>element(): 返回第一个元素 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.Queue;</span><br><span class="line"> </span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //add()和remove()方法在失败的时候会抛出异常(不推荐)</span><br><span class="line">        Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;();</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="关于栈和队列的题目"><a href="#关于栈和队列的题目" class="headerlink" title="关于栈和队列的题目"></a>关于栈和队列的题目</h3><h4 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h4><p>思路：<br>压入元素直接压入stack1，删除元素先查看stack2是否为空,在stack2中的栈顶元素是最先进入stack1的元素，非空则弹出；空则将stack1中元素取出，置于stack2中；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Problem9 &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    public void push(int node)&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int pop()&#123;</span><br><span class="line"></span><br><span class="line">        if(stack2.empty())&#123;</span><br><span class="line">            while(!stack1.empty())</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h4><p>描述：定义栈的数据结构，在该类型中实现一个能找到栈的最小值的min函数；在栈中，调用min，push，pop的时间复杂度都是O(1)；<br>思路：建立一个辅助栈，每次在主栈中压入一个元素时，就判断该数与辅助栈的栈顶元素比较，如果小于栈顶元素，就把该数压进辅助栈，反之则将辅助栈的栈顶元素再压进去辅助栈里；<br><img src="/2018/08/26/剑指offer笔记/1.png" title="状态图"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class StackWithMin &#123;</span><br><span class="line">        Stack&lt;Integer&gt; main = new Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; help = new Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        public void stackWithMinPush(int item) &#123;</span><br><span class="line">            main.push(item);</span><br><span class="line">            if (help.size() &gt; 0 || item &lt; help.peek()) &#123;</span><br><span class="line">                help.push(item);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                help.push(help.peek());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //main栈和min栈弹出元素</span><br><span class="line">        public void stackWithMinPop() &#123;</span><br><span class="line">            if (main.size() &gt; 0 &amp;&amp; help.size() &gt; 0) &#123;</span><br><span class="line">                main.pop();</span><br><span class="line">                help.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //main栈的栈顶元素</span><br><span class="line">        public int stackWithDataPeep() &#123;</span><br><span class="line">            if (main.size() &gt; 0) &#123;</span><br><span class="line">                return main.peek();</span><br><span class="line">            &#125;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //min栈的栈顶元素，栈顶元素为main栈中现有元素的最小元素</span><br><span class="line">        public int stackWithMinMin() &#123;</span><br><span class="line">            if (main.size() &gt; 0 &amp;&amp; help.size() &gt; 0) &#123;</span><br><span class="line">                return help.peek();</span><br><span class="line">            &#125;</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h4><p>描述：给定一个数组和滑动窗口的大小，找出所有滑动窗口的最大值；<br>例如，如果输入数组{2,3,4,2,6,2,5,1} 及滑动窗口的大小3，那么一共存在6个滑动窗口：{[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}，他们的最大值分别为{4,4,6,6,6,5}。</p><p>思路：</p><h2 id="动态规划与贪婪算法"><a href="#动态规划与贪婪算法" class="headerlink" title="动态规划与贪婪算法"></a>动态规划与贪婪算法</h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p> 应用于：大问题能分解为小问题，每个小问题也存在最优解，把小问题的最优解组合起来就是这个问题的最优解；</p><h3 id="贪婪算法"><a href="#贪婪算法" class="headerlink" title="贪婪算法"></a>贪婪算法</h3><p>应用于： 大问题分解为小问题，对于每一个小问题存在很多种解（很难求出最优解），此时我们选择一个相对好的解（基于某种贪婪策略），之后基于这个解而确定问题的最优解；</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>剑指Offer（第二版）面试题14：剪绳子<br><a href="https://blog.csdn.net/Koala_Tree/article/details/78932316" target="_blank" rel="noopener">https://blog.csdn.net/Koala_Tree/article/details/78932316</a></p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>在实际编程中位移运算比除法运算更加快速<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;      :     左移运算符，num &lt;&lt; 1,相当于num乘以2</span><br><span class="line">&gt;&gt;      :     右移运算符，num &gt;&gt; 1,相当于num除以2</span><br><span class="line">&gt;&gt;&gt;     :     无符号右移，忽略符号位，空位都以0补齐</span><br><span class="line">&amp;(按位与)：    只有两个操作数对应位同为1时，结果为1，否则为0.</span><br><span class="line">|(按位或):    只有两个操作数对应位同为0时，结果为0，否则为1.</span><br><span class="line">~(按位非):取反；</span><br><span class="line">^(异或)  :  只有两个数不相同时为1，否则为0；(用于二进制的加法)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> 1010      十进制：10     原始数         number</span><br><span class="line">10100      十进制：20     左移一位       number = number &lt;&lt; 1;</span><br><span class="line"> 1010      十进制：10     右移一位       number = number &gt;&gt; 1;</span><br></pre></td></tr></table></figure><p>Java位运算原理及使用讲解：<a href="https://blog.csdn.net/goskalrie/article/details/52796360" target="_blank" rel="noopener">https://blog.csdn.net/goskalrie/article/details/52796360</a></p><h3 id="输入一个整数求其二进制数中的1的个数"><a href="#输入一个整数求其二进制数中的1的个数" class="headerlink" title="输入一个整数求其二进制数中的1的个数"></a>输入一个整数求其二进制数中的1的个数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">得到的结论是：把一个整数减去<span class="number">1</span>，再和原整数做位与运算，会把该整数最右边的<span class="number">1</span>变为<span class="number">0</span>；</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Java使用补码来表示二进制数</span><br><span class="line">对正数来说 ,补码就是其二进制数。</span><br><span class="line">对 负 数 而 言 ,把该 数 绝 对 值 的 补 码 按 位 取 反 ,然后 对 整 个数 加 <span class="number">1</span>,即得 该 数的 补 码 。 如 -<span class="number">1</span>的补 码 为<span class="number">11111111111111111111111111111111</span>(<span class="number">00000000000000000000000000000001</span></span><br><span class="line">按 位 取 反 <span class="number">11111111111111111111111111111110</span>+<span class="number">1</span>=<span class="number">11111111111111111111111111111111</span> )。</span><br></pre></td></tr></table></figure><h2 id="翻转字符串"><a href="#翻转字符串" class="headerlink" title="翻转字符串"></a>翻转字符串</h2><h3 id="翻转单词顺序"><a href="#翻转单词顺序" class="headerlink" title="翻转单词顺序"></a>翻转单词顺序</h3><p>描述：输入一个英文句子，翻转句子中单词的顺序，但单词内字符串的顺序不变。例如输入字符串：“I am a student.”,则输出“student. a am I”.</p><p>思路：<br>第一步先将整个句子逆时针旋转180度得到：.tneduts a ma I<br>第二步在将句子中的单词逐个逆时针旋转180度得到：student. a am I</p><p>代码：</p><h4 id="方法1：使用String的split函数，将句子先分为几个单词，之后只需调换单词的顺序即可；"><a href="#方法1：使用String的split函数，将句子先分为几个单词，之后只需调换单词的顺序即可；" class="headerlink" title="方法1：使用String的split函数，将句子先分为几个单词，之后只需调换单词的顺序即可；"></a>方法1：使用String的split函数，将句子先分为几个单词，之后只需调换单词的顺序即可；</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static String ReverseSentence1(String str) &#123;</span><br><span class="line">        String trim = str.trim();</span><br><span class="line">        String a = &quot;&quot;;</span><br><span class="line">        if(&quot;&quot;.equals(str.trim()))&#123;</span><br><span class="line">            return str;</span><br><span class="line">        &#125;</span><br><span class="line">        //将字符串通过split函数将其分开，并用数组接收</span><br><span class="line">        String[] split = str.split(&quot; &quot;);</span><br><span class="line">        //反向拼接并用空格连接</span><br><span class="line">        //split:&#123;&quot;I&quot;,&quot;am&quot;,&quot;a&quot;,&quot;student.&quot;&#125;</span><br><span class="line">        for (int i = split.length-1; i &gt;=0; i--) &#123;</span><br><span class="line">            a += split[i]+&quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return a.trim();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static String ReverSentence2(String str) &#123;</span><br><span class="line">        return (str.lastIndexOf(&quot; &quot;)==-1)?str:str.substring(str.lastIndexOf(&quot; &quot;)+1) +&quot; &quot;+ReverSentence2(str.substring(0,str.lastIndexOf(&quot; &quot;)));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="方法3："><a href="#方法3：" class="headerlink" title="方法3："></a>方法3：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/*****反转单个字符串函数****/</span><br><span class="line">    public char[] reverseStr(char[] StrArr, int start, int end)</span><br><span class="line">    &#123;</span><br><span class="line">        if (StrArr == null)</span><br><span class="line">            return null;</span><br><span class="line"></span><br><span class="line">        while(start &lt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            char temp = StrArr[start];</span><br><span class="line">            StrArr[start ++] = StrArr[end];</span><br><span class="line">            StrArr[end --]   = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return StrArr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** 根据单词进行反转</span><br><span class="line">     *  策略是先反转整个字符串，在根据空格划分单词，然后依次反转每个单词*/</span><br><span class="line">    public String ReverSentence3(String dataStr)</span><br><span class="line">    &#123;</span><br><span class="line">        if(dataStr == null || dataStr.length() == 0)</span><br><span class="line">            return dataStr;</span><br><span class="line">        char[] dataArr = dataStr.toCharArray();</span><br><span class="line">        //反转整个字符串</span><br><span class="line">        int start = 0;</span><br><span class="line">        int end = dataStr.length() - 1;</span><br><span class="line">        reverseStr(dataArr, start, end);</span><br><span class="line">        //类似于双指针法，根据空格划分单词</span><br><span class="line">        start = end = 0;</span><br><span class="line">        while(start &lt; dataStr.length())</span><br><span class="line">        &#123;</span><br><span class="line">            //如果start为空格，则跳过它不把它识别为单词的一部分</span><br><span class="line">            if(dataArr[start] == &apos; &apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                start ++;</span><br><span class="line">                end ++;</span><br><span class="line">            &#125;</span><br><span class="line">            //当end指针移到字符串数组末尾，或者当前为空格，则start指针到end指针之间构成一个单词</span><br><span class="line">            else if(end == dataStr.length() || dataArr[end] == &apos; &apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                //注意end已经对应单词末尾后面一位，要注意先自减</span><br><span class="line">                reverseStr(dataArr, start, --end);</span><br><span class="line">                //开始识别下一个单词</span><br><span class="line">                start = ++ end;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                //此为一般情况，end指针一直后移</span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new String(dataArr);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h3><p>描述：输入一个字符串和一个整数n，将这个字符串的前n个字符转移到字符串的后面<br>例如：<br>input：abcdefg 2<br>output:  cdefgab</p><p>思路：将字符串分为两部分{ab},{cdefg},之后对这两部分做翻转得到{ba},{gfedc},再将这两部分合并{bagfedc}，之后再对这个字符串进行翻转 得到{cdefgab}；</p><p>代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static String ReverseSentence(String str,int n)&#123;</span><br><span class="line">        char[] ch1=reverseStr(str.substring(0,n).toCharArray(),0,str.substring(0,n).length()-1);</span><br><span class="line">        System.out.println(ch1);</span><br><span class="line">        char[] ch2=reverseStr(str.substring(n,str.length()).toCharArray(),0,str.substring(n,str.length()).length()-1);</span><br><span class="line">        System.out.println(ch2);</span><br><span class="line">        char[]chars=(new String(ch1)+new String(ch2)).toCharArray();</span><br><span class="line">        return new String(reverseStr(chars,0,chars.length-1));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="抽象建模"><a href="#抽象建模" class="headerlink" title="抽象建模"></a>抽象建模</h2><h3 id="扑克牌中的顺子"><a href="#扑克牌中的顺子" class="headerlink" title="扑克牌中的顺子"></a>扑克牌中的顺子</h3><p>描述: 从扑克牌中随机抽 5 张牌,判断是不是顺子,即这 5 张牌是不是连续的。2-10 为数字本身, A为1, J为1, Q为12,K为13, 而大小王可以看成任意的数字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Problem61 &#123;</span><br><span class="line">    private static boolean solution(int [] a)&#123;</span><br><span class="line">        if(a.length&lt;5||a==null) return false;</span><br><span class="line">        Arrays.sort(a);</span><br><span class="line">        int numberOfZero=0;</span><br><span class="line">        int numberOfGap=0;</span><br><span class="line">        for(int i=0;i&lt;a.length;i++)&#123;</span><br><span class="line">            if(a[i]==0) numberOfZero++;</span><br><span class="line">        &#125;</span><br><span class="line">        //比如有&#123;0,0,7,11,9&#125;，则从7开始计算，9和7相差9-7-1=1张牌</span><br><span class="line">        for(int i=numberOfZero;i&lt;4;i++)&#123;</span><br><span class="line">            if(a[i+1]-a[i]==0)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            numberOfGap+=a[i+1]-a[i]-1;</span><br><span class="line">        &#125;</span><br><span class="line">        return (numberOfGap&gt;numberOfZero)?false:true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a[]=&#123;0,0,7,11,9&#125;;</span><br><span class="line">        System.out.println(solution(a));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="约瑟夫环问题"><a href="#约瑟夫环问题" class="headerlink" title="约瑟夫环问题"></a>约瑟夫环问题</h3><p>描述：0，1，，，，，n-1这n 个数字排成一个圆圈，从数字0开始每次从这个圆圈中删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p><p>思路1：创建一个共有n个结点的环形链表，然后每次都从这个链表中删除第m个结点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public static int lastRemaining(int n, int m) &#123;</span><br><span class="line">        if (n &lt; 1 || m &lt; 1) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = new LinkedList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        // 要删除元素的位置</span><br><span class="line">        int idx = 0;</span><br><span class="line">        // 开始计数的位置</span><br><span class="line">        int start = 0;</span><br><span class="line">        while (list.size() &gt; 1) &#123;</span><br><span class="line">            // 只要移动m-1次就可以移动到下一个要删除的元素上</span><br><span class="line">            for (int i = 1; i &lt; m; i++) &#123;</span><br><span class="line">                idx = (idx + 1) % list.size(); // 【A】</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            list.remove(idx);</span><br><span class="line"></span><br><span class="line">            // 确保idx指向每一轮的第一个位置</span><br><span class="line">            // 下面的可以不用，【A】已经可以保证其正确性了，可以分析n=6，m=6的第一次删除情况</span><br><span class="line">            //  if (idx == list.size()) &#123;</span><br><span class="line">            //      idx = 0;</span><br><span class="line">            //  &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return list.get(0);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="求1-2-···-n"><a href="#求1-2-···-n" class="headerlink" title="求1+2+···+n;"></a>求1+2+···+n;</h3><p>要求： 不用乘除、for、while、if、else、switch、case、A?B:C<br>递归：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static int plus(int sum,int n)&#123;</span><br><span class="line">boolean is_end=true;</span><br><span class="line">sum+=n;</span><br><span class="line">is_end=(n&gt;0) &amp;&amp; ((sum=plus(sum,--n))&gt;0);</span><br><span class="line">return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="不用-做加法运算"><a href="#不用-做加法运算" class="headerlink" title="不用+ - * /做加法运算"></a>不用+ - * /做加法运算</h3><p>思路：位运算的异或实现<br>假设我们这来那个数分别为12和9，对应的二进制为：1100和1001，实现分三步走<br>1、首先只做加法，不考虑进位问题。结果为0101。相当于做异或运算，(1100^1001)=0101；<br>2、接着只考虑进位。只有1+1会发生进位，所以相当于做按位与运算， 得到结果：(1100&amp;1001)=1000；<br>3、在二进制中，1+1会发生进位。所以对于第二步的结果应该采用左移1位 1000&lt;&lt; = 10000</p><p>重复上面的步骤，对0101和10000进行加法运算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private static int add(int num1,int num2)&#123;</span><br><span class="line">       int sum,carry;</span><br><span class="line">       do&#123;</span><br><span class="line">           sum=num1^num2;</span><br><span class="line">           carry=(num1&amp;num2)&lt;&lt;1;</span><br><span class="line">           num1=sum;</span><br><span class="line">           num2=carry;</span><br><span class="line">       &#125;while(num2!=0);</span><br><span class="line">       return num1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="不使用中间变量交换两个变量的值"><a href="#不使用中间变量交换两个变量的值" class="headerlink" title="不使用中间变量交换两个变量的值"></a>不使用中间变量交换两个变量的值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a=a+b;</span><br><span class="line">b=a-b;</span><br><span class="line">a=a-b;</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">```java</span><br><span class="line"></span><br><span class="line">a=a^b;</span><br><span class="line">b=a^b;</span><br><span class="line">b=a^b;</span><br></pre></td></tr></table></figure><h2 id="Singleton模式的实现"><a href="#Singleton模式的实现" class="headerlink" title="Singleton模式的实现"></a>Singleton模式的实现</h2><p>所谓Singleton就是设计一个类，我们只能生成该类的一个实例；即单例模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance=new Singleton();</span><br><span class="line">    private Singleton()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个私有的内部类，在第一次用这个嵌套类时，会创建一个实例。而类型为SingletonHolder的类，只有在Singleton.getInstance()中调用，由于私有的属性，他人无法使用SingleHolder，不调用Singleton.getInstance()就不会创建实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    private static class SingletonHolder&#123;</span><br><span class="line">        private final static Singleton instance=new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        return SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>SSM框架</title>
      <link href="/2018/08/03/SSM%E6%A1%86%E6%9E%B6/"/>
      <url>/2018/08/03/SSM%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p>参考博文：</p><ul><li><a href="https://blog.csdn.net/qq598535550/article/details/51703190" target="_blank" rel="noopener">https://blog.csdn.net/qq598535550/article/details/51703190</a></li><li><a href="https://blog.csdn.net/qq_20805103/article/details/77488635" target="_blank" rel="noopener">https://blog.csdn.net/qq_20805103/article/details/77488635</a></li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Mybatis</title>
      <link href="/2018/07/30/Mybatis/"/>
      <url>/2018/07/30/Mybatis/</url>
      
        <content type="html"><![CDATA[<p>MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。<br>iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（DAOs）。<br>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。<br>MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。<br><a id="more"></a></p><h2 id="Mybatis框架简介"><a href="#Mybatis框架简介" class="headerlink" title="Mybatis框架简介"></a>Mybatis框架简介</h2><p>Mybatis是一个数据持久层（ORM）框架，把实体类和SQL语句之间建立了映射关系，是一种半自动化的ORM实现。</p><h3 id="传统JDBC操作"><a href="#传统JDBC操作" class="headerlink" title="传统JDBC操作"></a>传统JDBC操作</h3><p>1.加载数据库驱动<br>2.创建并获取数据库链接<br>3.创建jdbc statement对象<br>4.设置sql语句<br>5.设置sql语句中的参数(使用preparedStatement)<br>6.通过statement执行sql并获取结果<br>7.对sql执行结果进行解析处理<br>8.释放资源(resultSet、preparedstatement、connection)</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><pre><code>import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;public class JdbcTest {    public static void main(String[] args) {        //数据库连接        Connection connection = null;        //预编译的Statement，使用预编译的Statement提高数据库性能        PreparedStatement preparedStatement = null;        //结果集        ResultSet resultSet = null;        try {        //加载数据库驱动        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);        //通过驱动管理类获取数据库链接        connection =  DriverManager.getConnection(&quot;jdbc:mysql://120.25.162.238:3306/mybatis001?characterEncoding=utf-8&quot;, &quot;root&quot;, &quot;123&quot;);        //定义sql语句 ?表示占位符        String sql = &quot;select * from user where username = ?&quot;;        //获取预处理statement        preparedStatement = connection.prepareStatement(sql);        //设置参数，第一个参数为sql语句中参数的序号（从1开始），第二个参数为设置的参数值        preparedStatement.setString(1, &quot;王五&quot;);        //向数据库发出sql执行查询，查询出结果集        resultSet =  preparedStatement.executeQuery();        //遍历查询结果集        while(resultSet.next()){            System.out.println(resultSet.getString(&quot;id&quot;)+&quot;  &quot;+resultSet.getString(&quot;username&quot;));        }    } catch (Exception e) {        e.printStackTrace();    }finally{        //释放资源        if(resultSet!=null){            try {                resultSet.close();            } catch (SQLException e) {                // TODO Auto-generated catch block                e.printStackTrace();            }        }        if(preparedStatement!=null){            try {                preparedStatement.close();            } catch (SQLException e) {                // TODO Auto-generated catch block                e.printStackTrace();            }        }        if(connection!=null){            try {                connection.close();            } catch (SQLException e) {                // TODO Auto-generated catch block                e.printStackTrace();            }        }    }}}</code></pre><h4 id="存在问题—硬编码"><a href="#存在问题—硬编码" class="headerlink" title="存在问题—硬编码"></a>存在问题—硬编码</h4><p>1.数据库连接，使用时就创建，不使用立即释放，对数据库进行频繁连接开启和关闭，造成数据库资源浪费，影响数据库性能。</p><p>设想：使用数据库连接池管理数据库连接。</p><p>2.将sql语句硬编码到java代码中，如果sql语句修改，需要重新编译java代码，不利于系统维护。</p><p>设想：将sql语句配置在xml配置文件中，即使sql变化，不需要对java代码进行重新编译。</p><p>3.向preparedStatement中设置参数，对占位符号位置和设置参数值，硬编码在java代码中，不利于系统维护。</p><p>设想：将sql语句及占位符号和参数全部配置在xml中。</p><p>4.从resutSet中遍历结果集数据时，存在硬编码，将获取表的字段进行硬编码，不利于系统维护。</p><p>设想：将查询的结果集，自动映射成java对象。    </p><h3 id="使用mybatis的改进"><a href="#使用mybatis的改进" class="headerlink" title="使用mybatis的改进"></a>使用mybatis的改进</h3><h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><img src="/2018/07/30/Mybatis/架构图1.png" title="架构图"><pre><code>1.新建全局配置问文件SqlMapConfig.xml，    &lt;configuration&gt;        &lt;!-- 加载属性文件 --&gt;        &lt;properties resource=&quot;db.properties&quot;&gt;        &lt;/properties&gt;        &lt;!-- 和spring整合后 environments配置将废除--&gt;        &lt;environments default=&quot;development&quot;&gt;            &lt;environment id=&quot;development&quot;&gt;            &lt;!-- 使用jdbc事务管理，事务控制由mybatis--&gt;            &lt;transactionManager type=&quot;JDBC&quot; /&gt;            &lt;!-- 数据库连接池，由mybatis管理--&gt;                &lt;dataSource type=&quot;POOLED&quot;&gt;                    &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot; /&gt;                    &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;                    &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;                    &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;                &lt;/dataSource&gt;            &lt;/environment&gt;        &lt;/environments&gt;        &lt;!-- 加载 映射文件 ,里面可以放多个mapper分别对应不同的xml文件--&gt;        &lt;mappers&gt;            &lt;mapper resource=&quot;sqlmap/User.xml&quot;/&gt;        &lt;/mappers&gt;    &lt;/configuration&gt;2.新建user.xml映射文件，文件名user表示有一个user表，这个user.xml文件就是定义对user表的处理sql语句；比如查询语句    &lt;mapper namespace=&quot;test&quot;&gt;        &lt;!-- 在 映射文件中配置很多sql语句 --&gt;        &lt;!-- 需求：通过id查询用户表的记录 --&gt;        &lt;!-- 通过 select执行数据库查询--&gt;        &lt;!--id：标识映射文件中的 sql--&gt;        &lt;!--将sql语句封装到mappedStatement对象中，所以将id称为statement的id --&gt;        &lt;!--parameterType：指定输入 参数的类型，这里指定int型 --&gt;        &lt;!--#{}表示一个占位符号 --&gt;        &lt;!--#{id}：其中的id表示接收输入 的参数，参数名称就是id，如果输入 参数是简单类型，#{}中的参数名可以任意，可以value或其它名称--&gt;        &lt;!--resultType：指定sql输出结果 的所映射的java对象类型，select指定resultType表示将单条记录映射成的java对象。--&gt;         --&gt;        &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.neuedu.pojo.User&quot;&gt;            SELECT * FROM T_USER WHERE id=#{id}        &lt;/select    &lt;/mapper&gt;3.查询的功能代码的实现public void findUserByIdTest() throws IOException {    // mybatis配置文件    String resource = &quot;config/SqlMapConfig.xml&quot;;    // 得到配置文件流    InputStream inputStream = Resources.getResourceAsStream(resource);    // 创建会话工厂，传入mybatis的配置文件信息    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);    // 通过工厂得到SqlSession    SqlSession sqlSession = sqlSessionFactory.openSession();    // 通过SqlSession操作数据库    // 第一个参数：映射文件中statement的id，等于=namespace+&quot;.&quot;+statement的id    // 第二个参数：指定和映射文件中所匹配的parameterType类型的参数    // sqlSession.selectOne结果 是与映射文件中所匹配的resultType类型的对象    // selectOne查询出一条记录    User user = sqlSession.selectOne(&quot;test.findUserById&quot;, 1);    System.out.println(user);    // 释放资源    sqlSession.close();}</code></pre><h2 id="Mybatis开发dao方法"><a href="#Mybatis开发dao方法" class="headerlink" title="Mybatis开发dao方法"></a>Mybatis开发dao方法</h2><h3 id="原始dao开发"><a href="#原始dao开发" class="headerlink" title="原始dao开发"></a>原始dao开发</h3><p>dao接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据id查询用户信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUserById</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据用户名列查询用户列表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUserByName</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加用户信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUser</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除用户信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>dao接口实现类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.iot.mybatis.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.iot.mybatis.po.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">    <span class="comment">// 需要向dao实现类中注入SqlSessionFactory</span></span><br><span class="line">    <span class="comment">// 这里通过构造方法注入</span></span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserDaoImpl</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sqlSessionFactory = sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUserById</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        User user = sqlSession.selectOne(<span class="string">"test.findUserById"</span>,id);</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUserByName</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; list = sqlSession.selectList(<span class="string">"test.findUserByName"</span>, name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUser</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        <span class="comment">//执行插入操作</span></span><br><span class="line">        sqlSession.insert(<span class="string">"test.insertUser"</span>, user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交事务</span></span><br><span class="line">        sqlSession.commit();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行插入操作</span></span><br><span class="line">        sqlSession.delete(<span class="string">"test.deleteUser"</span>, id);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交事务</span></span><br><span class="line">        sqlSession.commit();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.iot.mybatis.dao;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> com.iot.mybatis.po.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImplTest</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此方法是在执行testFindUserById之前执行</span></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建sqlSessionFactory</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// mybatis配置文件</span></span><br><span class="line">        String resource = <span class="string">"SqlMapConfig.xml"</span>;</span><br><span class="line">        <span class="comment">// 得到配置文件流</span></span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建会话工厂，传入mybatis的配置文件信息</span></span><br><span class="line">        sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder()</span><br><span class="line">                .build(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindUserById</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建UserDao的对象</span></span><br><span class="line">        UserDao userDao = <span class="keyword">new</span> UserDaoImpl(sqlSessionFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用UserDao的方法</span></span><br><span class="line">        User user = userDao.findUserById(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总结原始dao开发问题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.dao接口实现类方法中存在大量模板方法，设想能否将这些代码提取出来，大大减轻程序员的工作量。</span><br><span class="line"><span class="number">2</span>.调用sqlsession方法时将statement的id硬编码了</span><br><span class="line"><span class="number">3</span>.调用sqlsession方法时传入的变量，由于sqlsession方法使用泛型，即使变量类型传入错误，在编译阶段也不报错，不利于程序员开发。</span><br><span class="line"><span class="number">4</span>.程序员需要写dao接口和dao实现类</span><br></pre></td></tr></table></figure></p><h3 id="mapper代理开发"><a href="#mapper代理开发" class="headerlink" title="mapper代理开发"></a>mapper代理开发</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">程序员只需要mapper接口（相当 于dao接口）</span><br><span class="line">程序员还需要编写mapper.xml映射文件</span><br><span class="line">程序员编写mapper接口需要遵循一些开发规范，mybatis可以自动生成mapper接口实现类代理对象。具体的规范如下：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>.在mapper.xml中namespace等于mapper接口地址；</span><br><span class="line">&lt;mapper namespace=<span class="string">"com.iot.mybatis.mapper.UserMapper"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.mapper.java接口中的方法名和mapper.xml中statement的id一致；</span><br><span class="line"><span class="number">3</span>.mapper.java接口中的方法输入参数类型和mapper.xml中statement的parameterType指定的类型一致；</span><br><span class="line">&lt;select id=<span class="string">"findUserById"</span> parameterType=<span class="string">"int"</span> resultType=<span class="string">"com.iot.mybatis.po.User"</span>&gt;</span><br><span class="line">    SELECT * FROM  user  WHERE id=#&#123;value&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">findUserById</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="number">4</span>.mapper.java接口中的方法返回值类型和mapper.xml中statement的resultType指定的类型一致；</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">总结：以上开发规范主要是对下边的代码进行统一生成：</span><br><span class="line"></span><br><span class="line">User user = sqlSession.selectOne(<span class="string">"test.findUserById"</span>, id);</span><br><span class="line">sqlSession.insert(<span class="string">"test.insertUser"</span>, user);</span><br></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><p>mapper.xml</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC <span class="string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line">        <span class="string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span><br><span class="line">&lt;!--</span><br><span class="line"> namespace 命名空间，作用就是对sql进行分类化管理,理解为sql隔离</span><br><span class="line"> 注意：使用mapper代理方法开发，namespace有特殊重要的作用</span><br><span class="line"> --&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">"com.iot.mybatis.mapper.UserMapper"</span>&gt;</span><br><span class="line"> &lt;!-- 在映射文件中配置很多sql语句 --&gt;</span><br><span class="line">    &lt;!--需求:通过id查询用户表的记录 --&gt;</span><br><span class="line">    &lt;!-- 通过select执行数据库查询</span><br><span class="line">     id:标识映射文件中的sql，称为statement的id</span><br><span class="line">     将sql语句封装到mappedStatement对象中，所以将id称为statement的id</span><br><span class="line">     parameterType:指定输入参数的类型</span><br><span class="line">     #&#123;&#125;标示一个占位符,</span><br><span class="line">     #&#123;value&#125;其中value表示接收输入参数的名称，如果输入参数是简单类型，那么#&#123;&#125;中的值可以任意。</span><br><span class="line"></span><br><span class="line">     resultType：指定sql输出结果的映射的java对象类型，select指定resultType表示将单条记录映射成java对象</span><br><span class="line">     --&gt;</span><br><span class="line">    &lt;select id=<span class="string">"findUserById"</span> parameterType=<span class="string">"int"</span> resultType=<span class="string">"com.iot.mybatis.po.User"</span>&gt;</span><br><span class="line">        SELECT * FROM  user  WHERE id=#&#123;value&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 根据用户名称模糊查询用户信息，可能返回多条</span><br><span class="line">    resultType：指定就是单条记录所映射的java对象类型</span><br><span class="line">    $&#123;&#125;:表示拼接sql串，将接收到参数的内容不加任何修饰拼接在sql中。</span><br><span class="line">    使用$&#123;&#125;拼接sql，引起 sql注入</span><br><span class="line">    $&#123;value&#125;：接收输入参数的内容，如果传入类型是简单类型，$&#123;&#125;中只能使用value</span><br><span class="line">     --&gt;</span><br><span class="line">    &lt;select id=<span class="string">"findUserByName"</span> parameterType=<span class="string">"java.lang.String"</span> resultType=<span class="string">"com.iot.mybatis.po.User"</span>&gt;</span><br><span class="line">        SELECT * FROM user WHERE username LIKE <span class="string">'%$&#123;value&#125;%'</span></span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- 添加用户</span><br><span class="line">        parameterType：指定输入 参数类型是pojo（包括 用户信息）</span><br><span class="line">        #&#123;&#125;中指定pojo的属性名，接收到pojo对象的属性值，mybatis通过OGNL获取对象的属性值</span><br><span class="line">        --&gt;</span><br><span class="line">    &lt;insert id=<span class="string">"insertUser"</span> parameterType=<span class="string">"com.iot.mybatis.po.User"</span>&gt;</span><br><span class="line">        &lt;!--</span><br><span class="line">         将插入数据的主键返回，返回到user对象中</span><br><span class="line"></span><br><span class="line">         <span class="function">SELECT <span class="title">LAST_INSERT_ID</span><span class="params">()</span>：得到刚insert进去记录的主键值，只适用与自增主键</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">         keyProperty：将查询到主键值设置到parameterType指定的对象的哪个属性</span></span><br><span class="line"><span class="function">         order：SELECT <span class="title">LAST_INSERT_ID</span><span class="params">()</span>执行顺序，相对于insert语句来说它的执行顺序</span></span><br><span class="line"><span class="function">         resultType：指定SELECT <span class="title">LAST_INSERT_ID</span><span class="params">()</span>的结果类型</span></span><br><span class="line"><span class="function">          --&gt;</span></span><br><span class="line"><span class="function">        &lt;selectKey keyProperty</span>=<span class="string">"id"</span> order=<span class="string">"AFTER"</span> resultType=<span class="string">"java.lang.Integer"</span>&gt;</span><br><span class="line">          <span class="function">SELECT <span class="title">LAST_INSERT_ID</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        &lt;/selectKey&gt;</span></span><br><span class="line"><span class="function">        INSERT INTO <span class="title">user</span> <span class="params">(username,birthday,sex,address)</span><span class="title">values</span> <span class="params">(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)</span></span></span><br><span class="line"><span class="function">        &lt;!--</span></span><br><span class="line"><span class="function">            使用mysql的uuid（）生成主键</span></span><br><span class="line"><span class="function">            执行过程：</span></span><br><span class="line"><span class="function">            首先通过<span class="title">uuid</span><span class="params">()</span>得到主键，将主键设置到user对象的id属性中</span></span><br><span class="line"><span class="function">            其次在insert执行时，从user对象中取出id属性值</span></span><br><span class="line"><span class="function">             --&gt;</span></span><br><span class="line"><span class="function">        &lt;!--  &lt;selectKey keyProperty</span>=<span class="string">"id"</span> order=<span class="string">"BEFORE"</span> resultType=<span class="string">"java.lang.String"</span>&gt;</span><br><span class="line">            <span class="function">SELECT <span class="title">uuid</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        &lt;/selectKey&gt;</span></span><br><span class="line"><span class="function">        insert into <span class="title">user</span><span class="params">(id,username,birthday,sex,address)</span> <span class="title">value</span><span class="params">(#&#123;id&#125;,#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)</span> --&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    &lt;/insert&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    &lt;!-- 删除 用户</span></span><br><span class="line"><span class="function">        根据id删除用户，需要输入 id值</span></span><br><span class="line"><span class="function">         --&gt;</span></span><br><span class="line"><span class="function">    &lt;delete id</span>=<span class="string">"deleteUser"</span> parameterType=<span class="string">"java.lang.Integer"</span>&gt;</span><br><span class="line">        delete from user where id=#&#123;id&#125;</span><br><span class="line">    &lt;/delete&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 根据id更新用户</span><br><span class="line">    分析：</span><br><span class="line">    需要传入用户的id</span><br><span class="line">    需要传入用户的更新信息</span><br><span class="line">    parameterType指定user对象，包括 id和更新信息，注意：id必须存在</span><br><span class="line">    #&#123;id&#125;：从输入 user对象中获取id属性值</span><br><span class="line">     --&gt;</span><br><span class="line">    &lt;update id=<span class="string">"updateUser"</span> parameterType=<span class="string">"com.iot.mybatis.po.User"</span>&gt;</span><br><span class="line">        update user set username=#&#123;username&#125;,birthday=#&#123;birthday&#125;,sex=#&#123;sex&#125;,address=#&#123;address&#125;</span><br><span class="line">        where id=#&#123;id&#125;</span><br><span class="line">    &lt;/update&gt;</span><br><span class="line"></span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></li><li><p>在SqlMapConfig.xml中加载映射文件</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;mappers&gt;  </span><br><span class="line">    &lt;mapper resource=<span class="string">"mapper/UserMapper.xml"</span>/&gt;  </span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure></li><li><p>UserMapper.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据id查询用户信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUserById</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据用户名列查询用户列表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUserByName</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加用户信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUser</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除用户信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新用户</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(User user)</span><span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>UserMapperTest.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapperTest</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//注解Before是在执行本类所有测试方法之前先调用这个方法  </span></span><br><span class="line">    <span class="meta">@Before</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;  </span><br><span class="line">        <span class="comment">//创建SqlSessionFactory  </span></span><br><span class="line">        String resource=<span class="string">"SqlMapConfig.xml"</span>;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//将配置文件加载成流  </span></span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);  </span><br><span class="line">        <span class="comment">//创建会话工厂，传入mybatis配置文件的信息  </span></span><br><span class="line">        sqlSessionFactory=<span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span>  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindUserById</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;  </span><br><span class="line"></span><br><span class="line">        SqlSession sqlSession=sqlSessionFactory.openSession();  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建UserMapper代理对象  </span></span><br><span class="line">        UserMapper userMapper=sqlSession.getMapper(UserMapper.class);  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用userMapper的方法  </span></span><br><span class="line">        User user=userMapper.findUserById(<span class="number">1</span>);  </span><br><span class="line"></span><br><span class="line">        System.out.println(user.getUsername());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Mybatis-逆向工程"><a href="#Mybatis-逆向工程" class="headerlink" title="Mybatis 逆向工程"></a>Mybatis 逆向工程</h2><p>mybaits需要程序员自己编写sql语句,mybatis官方提供逆向工程,可以针对单表自动生成mybatis执行所需要的代码（mapper.java,mapper.xml、实体类）</p><h3 id="在MySQL中建表"><a href="#在MySQL中建表" class="headerlink" title="在MySQL中建表"></a>在MySQL中建表</h3><img src="/2018/07/30/Mybatis/2.PNG" title="user表"><h3 id="配置generatorConfig-xml文件"><a href="#配置generatorConfig-xml文件" class="headerlink" title="配置generatorConfig.xml文件"></a>配置generatorConfig.xml文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE generatorConfiguration</span><br><span class="line">  PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span><br><span class="line">  &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;generatorConfiguration&gt;</span><br><span class="line">&lt;context id=&quot;testTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;</span><br><span class="line">&lt;commentGenerator&gt;</span><br><span class="line">&lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;</span><br><span class="line">&lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">&lt;/commentGenerator&gt;</span><br><span class="line">&lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt;</span><br><span class="line"> &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">connectionURL=&quot;jdbc:mysql://localhost:3306/mybatis&quot; userId=&quot;root&quot;</span><br><span class="line">password=&quot;&quot;&gt;</span><br><span class="line">&lt;/jdbcConnection&gt; </span><br><span class="line"></span><br><span class="line">&lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 </span><br><span class="line">NUMERIC 类型解析为java.math.BigDecimal --&gt;</span><br><span class="line">&lt;javaTypeResolver&gt;</span><br><span class="line">&lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt;</span><br><span class="line">&lt;/javaTypeResolver&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- targetProject:生成PO类的位置 --&gt;</span><br><span class="line">&lt;javaModelGenerator targetPackage=&quot;com.soft.pojo&quot;</span><br><span class="line">targetProject=&quot;.\src&quot;&gt;</span><br><span class="line">&lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;</span><br><span class="line">&lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;</span><br><span class="line">&lt;!-- 从数据库返回的值被清理前后的空格 --&gt;</span><br><span class="line">&lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">&lt;/javaModelGenerator&gt;</span><br><span class="line">        &lt;!-- targetProject:mapper映射文件生成的位置 --&gt;</span><br><span class="line">&lt;sqlMapGenerator targetPackage=&quot;com.soft.mapper&quot; </span><br><span class="line">targetProject=&quot;.\src&quot;&gt;</span><br><span class="line">&lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;</span><br><span class="line">&lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;</span><br><span class="line">&lt;/sqlMapGenerator&gt;</span><br><span class="line">&lt;!-- targetPackage：mapper接口生成的位置 --&gt;</span><br><span class="line">&lt;javaClientGenerator type=&quot;XMLMAPPER&quot;</span><br><span class="line">targetPackage=&quot;com.soft.mapper&quot; </span><br><span class="line">targetProject=&quot;.\src&quot;&gt;</span><br><span class="line">&lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;</span><br><span class="line">&lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;</span><br><span class="line">&lt;/javaClientGenerator&gt;</span><br><span class="line">&lt;!-- 指定数据库表 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;table tableName=&quot;t_user&quot; domainObjectName=&quot;User&quot;</span><br><span class="line"> enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot;    </span><br><span class="line">               enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot; &gt;</span><br><span class="line">               &lt;columnOverride column=&quot;id&quot; javaType=&quot;Integer&quot; /&gt;</span><br><span class="line">         &lt;/table&gt;</span><br><span class="line"></span><br><span class="line">&lt;/context&gt;</span><br><span class="line">&lt;/generatorConfiguration&gt;</span><br></pre></td></tr></table></figure><h3 id="在本地lib导入jar包（或者用maven导入）"><a href="#在本地lib导入jar包（或者用maven导入）" class="headerlink" title="在本地lib导入jar包（或者用maven导入）"></a>在本地lib导入jar包（或者用maven导入）</h3><img src="/2018/07/30/Mybatis/1.PNG" title="需要的jar包"><h3 id="在src下编写log4j-properties"><a href="#在src下编写log4j-properties" class="headerlink" title="在src下编写log4j.properties"></a>在src下编写log4j.properties</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">log4j.rootLogger=DEBUG, Console</span><br><span class="line">#Console</span><br><span class="line">log4j.appender.Console=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.Console.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.Console.layout.ConversionPattern=%d [%t] %-5p [%c] - %m%n</span><br><span class="line">log4j.logger.java.sql.ResultSet=INFO</span><br><span class="line">log4j.logger.org.apache=INFO</span><br><span class="line">log4j.logger.java.sql.Connection=DEBUG</span><br><span class="line">log4j.logger.java.sql.Statement=DEBUG</span><br><span class="line">log4j.logger.java.sql.PreparedStatement=DEBUG</span><br></pre></td></tr></table></figure><h3 id="编写实现类"><a href="#编写实现类" class="headerlink" title="编写实现类"></a>编写实现类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package com.soft.generator;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import org.mybatis.generator.api.MyBatisGenerator;</span><br><span class="line">import org.mybatis.generator.config.Configuration;</span><br><span class="line">import org.mybatis.generator.config.xml.ConfigurationParser;</span><br><span class="line">import org.mybatis.generator.exception.XMLParserException;</span><br><span class="line">import org.mybatis.generator.internal.DefaultShellCallback;</span><br><span class="line">public class Generator &#123;</span><br><span class="line">public void generator() throws Exception&#123;</span><br><span class="line">List&lt;String&gt; warnings = new ArrayList&lt;String&gt;();</span><br><span class="line">boolean overwrite = true;</span><br><span class="line">//指定 逆向工程配置文件</span><br><span class="line">File configFile = new File(&quot;generatorConfig.xml&quot;); </span><br><span class="line">ConfigurationParser cp = new ConfigurationParser(warnings);</span><br><span class="line">Configuration config = cp.parseConfiguration(configFile);</span><br><span class="line">DefaultShellCallback callback = new DefaultShellCallback(overwrite);</span><br><span class="line">MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config,</span><br><span class="line">callback, warnings);</span><br><span class="line">myBatisGenerator.generate(null);</span><br><span class="line">&#125; </span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">try &#123;</span><br><span class="line">Generator generator = new Generator();</span><br><span class="line">generator.generator();</span><br><span class="line">System.out.print(&quot;end&quot;);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p>根据generatorConfig生成以下文件</p><ul><li>com.soft.mapper<ul><li>UserMapper.java</li><li>UserMapper.xml</li></ul></li><li>com.soft.pojo<ul><li>User.java<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.soft.mapper;</span><br><span class="line"></span><br><span class="line">import com.soft.pojo.User;</span><br><span class="line"></span><br><span class="line">public interface UserMapper &#123;</span><br><span class="line">    int deleteByPrimaryKey(Integer id);</span><br><span class="line"></span><br><span class="line">    int insert(User record);</span><br><span class="line"></span><br><span class="line">    int insertSelective(User record);</span><br><span class="line"></span><br><span class="line">    User selectByPrimaryKey(Integer id);</span><br><span class="line"></span><br><span class="line">    int updateByPrimaryKeySelective(User record);</span><br><span class="line"></span><br><span class="line">    int updateByPrimaryKey(User record);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.soft.mapper.UserMapper&quot;&gt;</span><br><span class="line">  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.soft.pojo.User&quot;&gt;</span><br><span class="line">    &lt;id column=&quot;id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;id&quot; /&gt;</span><br><span class="line">    &lt;result column=&quot;username&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;username&quot; /&gt;</span><br><span class="line">    &lt;result column=&quot;sex&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;sex&quot; /&gt;</span><br><span class="line">    &lt;result column=&quot;birthday&quot; jdbcType=&quot;DATE&quot; property=&quot;birthday&quot; /&gt;</span><br><span class="line">    &lt;result column=&quot;address&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;address&quot; /&gt;</span><br><span class="line">  &lt;/resultMap&gt;</span><br><span class="line">  &lt;sql id=&quot;Base_Column_List&quot;&gt;</span><br><span class="line">    id, username, sex, birthday, address</span><br><span class="line">  &lt;/sql&gt;</span><br><span class="line">  &lt;select id=&quot;selectByPrimaryKey&quot; parameterType=&quot;Integer&quot; resultMap=&quot;BaseResultMap&quot;&gt;</span><br><span class="line">    select </span><br><span class="line">    &lt;include refid=&quot;Base_Column_List&quot; /&gt;</span><br><span class="line">    from t_user</span><br><span class="line">    where id = #&#123;id,jdbcType=INTEGER&#125;</span><br><span class="line">  &lt;/select&gt;</span><br><span class="line">  &lt;delete id=&quot;deleteByPrimaryKey&quot; parameterType=&quot;Integer&quot;&gt;</span><br><span class="line">    delete from t_user</span><br><span class="line">    where id = #&#123;id,jdbcType=INTEGER&#125;</span><br><span class="line">  &lt;/delete&gt;</span><br><span class="line">  &lt;insert id=&quot;insert&quot; parameterType=&quot;com.soft.pojo.User&quot;&gt;</span><br><span class="line">    insert into t_user (id, username, sex, </span><br><span class="line">      birthday, address)</span><br><span class="line">    values (#&#123;id,jdbcType=INTEGER&#125;, #&#123;username,jdbcType=VARCHAR&#125;, #&#123;sex,jdbcType=VARCHAR&#125;, </span><br><span class="line">      #&#123;birthday,jdbcType=DATE&#125;, #&#123;address,jdbcType=VARCHAR&#125;)</span><br><span class="line">  &lt;/insert&gt;</span><br><span class="line">  &lt;insert id=&quot;insertSelective&quot; parameterType=&quot;com.soft.pojo.User&quot;&gt;</span><br><span class="line">    insert into t_user</span><br><span class="line">    &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt;</span><br><span class="line">      &lt;if test=&quot;id != null&quot;&gt;</span><br><span class="line">        id,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;username != null&quot;&gt;</span><br><span class="line">        username,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;sex != null&quot;&gt;</span><br><span class="line">        sex,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;birthday != null&quot;&gt;</span><br><span class="line">        birthday,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;address != null&quot;&gt;</span><br><span class="line">        address,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">    &lt;/trim&gt;</span><br><span class="line">    &lt;trim prefix=&quot;values (&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt;</span><br><span class="line">      &lt;if test=&quot;id != null&quot;&gt;</span><br><span class="line">        #&#123;id,jdbcType=INTEGER&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;username != null&quot;&gt;</span><br><span class="line">        #&#123;username,jdbcType=VARCHAR&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;sex != null&quot;&gt;</span><br><span class="line">        #&#123;sex,jdbcType=VARCHAR&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;birthday != null&quot;&gt;</span><br><span class="line">        #&#123;birthday,jdbcType=DATE&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;address != null&quot;&gt;</span><br><span class="line">        #&#123;address,jdbcType=VARCHAR&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">    &lt;/trim&gt;</span><br><span class="line">  &lt;/insert&gt;</span><br><span class="line">  &lt;update id=&quot;updateByPrimaryKeySelective&quot; parameterType=&quot;com.soft.pojo.User&quot;&gt;</span><br><span class="line">    update t_user</span><br><span class="line">    &lt;set&gt;</span><br><span class="line">      &lt;if test=&quot;username != null&quot;&gt;</span><br><span class="line">        username = #&#123;username,jdbcType=VARCHAR&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;sex != null&quot;&gt;</span><br><span class="line">        sex = #&#123;sex,jdbcType=VARCHAR&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;birthday != null&quot;&gt;</span><br><span class="line">        birthday = #&#123;birthday,jdbcType=DATE&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;address != null&quot;&gt;</span><br><span class="line">        address = #&#123;address,jdbcType=VARCHAR&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">    &lt;/set&gt;</span><br><span class="line">    where id = #&#123;id,jdbcType=INTEGER&#125;</span><br><span class="line">  &lt;/update&gt;</span><br><span class="line">  &lt;update id=&quot;updateByPrimaryKey&quot; parameterType=&quot;com.soft.pojo.User&quot;&gt;</span><br><span class="line">    update t_user</span><br><span class="line">    set username = #&#123;username,jdbcType=VARCHAR&#125;,</span><br><span class="line">      sex = #&#123;sex,jdbcType=VARCHAR&#125;,</span><br><span class="line">      birthday = #&#123;birthday,jdbcType=DATE&#125;,</span><br><span class="line">      address = #&#123;address,jdbcType=VARCHAR&#125;</span><br><span class="line">    where id = #&#123;id,jdbcType=INTEGER&#125;</span><br><span class="line">  &lt;/update&gt;</span><br><span class="line">  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.soft.pojo.User&quot;&gt;</span><br><span class="line">    &lt;id column=&quot;id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;id&quot; /&gt;</span><br><span class="line">    &lt;result column=&quot;username&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;username&quot; /&gt;</span><br><span class="line">    &lt;result column=&quot;sex&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;sex&quot; /&gt;</span><br><span class="line">    &lt;result column=&quot;birthday&quot; jdbcType=&quot;DATE&quot; property=&quot;birthday&quot; /&gt;</span><br><span class="line">    &lt;result column=&quot;address&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;address&quot; /&gt;</span><br><span class="line">  &lt;/resultMap&gt;</span><br><span class="line">  &lt;sql id=&quot;Base_Column_List&quot;&gt;</span><br><span class="line">    id, username, sex, birthday, address</span><br><span class="line">  &lt;/sql&gt;</span><br><span class="line">  &lt;select id=&quot;selectByPrimaryKey&quot; parameterType=&quot;Integer&quot; resultMap=&quot;BaseResultMap&quot;&gt;</span><br><span class="line">    select </span><br><span class="line">    &lt;include refid=&quot;Base_Column_List&quot; /&gt;</span><br><span class="line">    from t_user</span><br><span class="line">    where id = #&#123;id,jdbcType=INTEGER&#125;</span><br><span class="line">  &lt;/select&gt;</span><br><span class="line">  &lt;delete id=&quot;deleteByPrimaryKey&quot; parameterType=&quot;Integer&quot;&gt;</span><br><span class="line">    delete from t_user</span><br><span class="line">    where id = #&#123;id,jdbcType=INTEGER&#125;</span><br><span class="line">  &lt;/delete&gt;</span><br><span class="line">  &lt;insert id=&quot;insert&quot; parameterType=&quot;com.soft.pojo.User&quot;&gt;</span><br><span class="line">    insert into t_user (id, username, sex, </span><br><span class="line">      birthday, address)</span><br><span class="line">    values (#&#123;id,jdbcType=INTEGER&#125;, #&#123;username,jdbcType=VARCHAR&#125;, #&#123;sex,jdbcType=VARCHAR&#125;, </span><br><span class="line">      #&#123;birthday,jdbcType=DATE&#125;, #&#123;address,jdbcType=VARCHAR&#125;)</span><br><span class="line">  &lt;/insert&gt;</span><br><span class="line">  &lt;insert id=&quot;insertSelective&quot; parameterType=&quot;com.soft.pojo.User&quot;&gt;</span><br><span class="line">    insert into t_user</span><br><span class="line">    &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt;</span><br><span class="line">      &lt;if test=&quot;id != null&quot;&gt;</span><br><span class="line">        id,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;username != null&quot;&gt;</span><br><span class="line">        username,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;sex != null&quot;&gt;</span><br><span class="line">        sex,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;birthday != null&quot;&gt;</span><br><span class="line">        birthday,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;address != null&quot;&gt;</span><br><span class="line">        address,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">    &lt;/trim&gt;</span><br><span class="line">    &lt;trim prefix=&quot;values (&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt;</span><br><span class="line">      &lt;if test=&quot;id != null&quot;&gt;</span><br><span class="line">        #&#123;id,jdbcType=INTEGER&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;username != null&quot;&gt;</span><br><span class="line">        #&#123;username,jdbcType=VARCHAR&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;sex != null&quot;&gt;</span><br><span class="line">        #&#123;sex,jdbcType=VARCHAR&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;birthday != null&quot;&gt;</span><br><span class="line">        #&#123;birthday,jdbcType=DATE&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;address != null&quot;&gt;</span><br><span class="line">        #&#123;address,jdbcType=VARCHAR&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">    &lt;/trim&gt;</span><br><span class="line">  &lt;/insert&gt;</span><br><span class="line">  &lt;update id=&quot;updateByPrimaryKeySelective&quot; parameterType=&quot;com.soft.pojo.User&quot;&gt;</span><br><span class="line">    update t_user</span><br><span class="line">    &lt;set&gt;</span><br><span class="line">      &lt;if test=&quot;username != null&quot;&gt;</span><br><span class="line">        username = #&#123;username,jdbcType=VARCHAR&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;sex != null&quot;&gt;</span><br><span class="line">        sex = #&#123;sex,jdbcType=VARCHAR&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;birthday != null&quot;&gt;</span><br><span class="line">        birthday = #&#123;birthday,jdbcType=DATE&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;address != null&quot;&gt;</span><br><span class="line">        address = #&#123;address,jdbcType=VARCHAR&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">    &lt;/set&gt;</span><br><span class="line">    where id = #&#123;id,jdbcType=INTEGER&#125;</span><br><span class="line">  &lt;/update&gt;</span><br><span class="line">  &lt;update id=&quot;updateByPrimaryKey&quot; parameterType=&quot;com.soft.pojo.User&quot;&gt;</span><br><span class="line">    update t_user</span><br><span class="line">    set username = #&#123;username,jdbcType=VARCHAR&#125;,</span><br><span class="line">      sex = #&#123;sex,jdbcType=VARCHAR&#125;,</span><br><span class="line">      birthday = #&#123;birthday,jdbcType=DATE&#125;,</span><br><span class="line">      address = #&#123;address,jdbcType=VARCHAR&#125;</span><br><span class="line">    where id = #&#123;id,jdbcType=INTEGER&#125;</span><br><span class="line">  &lt;/update&gt;</span><br><span class="line">  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.soft.pojo.User&quot;&gt;</span><br><span class="line">    &lt;id column=&quot;id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;id&quot; /&gt;</span><br><span class="line">    &lt;result column=&quot;username&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;username&quot; /&gt;</span><br><span class="line">    &lt;result column=&quot;sex&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;sex&quot; /&gt;</span><br><span class="line">    &lt;result column=&quot;birthday&quot; jdbcType=&quot;DATE&quot; property=&quot;birthday&quot; /&gt;</span><br><span class="line">    &lt;result column=&quot;address&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;address&quot; /&gt;</span><br><span class="line">  &lt;/resultMap&gt;</span><br><span class="line">  &lt;sql id=&quot;Base_Column_List&quot;&gt;</span><br><span class="line">    id, username, sex, birthday, address</span><br><span class="line">  &lt;/sql&gt;</span><br><span class="line">  &lt;select id=&quot;selectByPrimaryKey&quot; parameterType=&quot;Integer&quot; resultMap=&quot;BaseResultMap&quot;&gt;</span><br><span class="line">    select </span><br><span class="line">    &lt;include refid=&quot;Base_Column_List&quot; /&gt;</span><br><span class="line">    from t_user</span><br><span class="line">    where id = #&#123;id,jdbcType=INTEGER&#125;</span><br><span class="line">  &lt;/select&gt;</span><br><span class="line">  &lt;delete id=&quot;deleteByPrimaryKey&quot; parameterType=&quot;Integer&quot;&gt;</span><br><span class="line">    delete from t_user</span><br><span class="line">    where id = #&#123;id,jdbcType=INTEGER&#125;</span><br><span class="line">  &lt;/delete&gt;</span><br><span class="line">  &lt;insert id=&quot;insert&quot; parameterType=&quot;com.soft.pojo.User&quot;&gt;</span><br><span class="line">    insert into t_user (id, username, sex, </span><br><span class="line">      birthday, address)</span><br><span class="line">    values (#&#123;id,jdbcType=INTEGER&#125;, #&#123;username,jdbcType=VARCHAR&#125;, #&#123;sex,jdbcType=VARCHAR&#125;, </span><br><span class="line">      #&#123;birthday,jdbcType=DATE&#125;, #&#123;address,jdbcType=VARCHAR&#125;)</span><br><span class="line">  &lt;/insert&gt;</span><br><span class="line">  &lt;insert id=&quot;insertSelective&quot; parameterType=&quot;com.soft.pojo.User&quot;&gt;</span><br><span class="line">    insert into t_user</span><br><span class="line">    &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt;</span><br><span class="line">      &lt;if test=&quot;id != null&quot;&gt;</span><br><span class="line">        id,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;username != null&quot;&gt;</span><br><span class="line">        username,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;sex != null&quot;&gt;</span><br><span class="line">        sex,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;birthday != null&quot;&gt;</span><br><span class="line">        birthday,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;address != null&quot;&gt;</span><br><span class="line">        address,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">    &lt;/trim&gt;</span><br><span class="line">    &lt;trim prefix=&quot;values (&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt;</span><br><span class="line">      &lt;if test=&quot;id != null&quot;&gt;</span><br><span class="line">        #&#123;id,jdbcType=INTEGER&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;username != null&quot;&gt;</span><br><span class="line">        #&#123;username,jdbcType=VARCHAR&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;sex != null&quot;&gt;</span><br><span class="line">        #&#123;sex,jdbcType=VARCHAR&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;birthday != null&quot;&gt;</span><br><span class="line">        #&#123;birthday,jdbcType=DATE&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;address != null&quot;&gt;</span><br><span class="line">        #&#123;address,jdbcType=VARCHAR&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">    &lt;/trim&gt;</span><br><span class="line">  &lt;/insert&gt;</span><br><span class="line">  &lt;update id=&quot;updateByPrimaryKeySelective&quot; parameterType=&quot;com.soft.pojo.User&quot;&gt;</span><br><span class="line">    update t_user</span><br><span class="line">    &lt;set&gt;</span><br><span class="line">      &lt;if test=&quot;username != null&quot;&gt;</span><br><span class="line">        username = #&#123;username,jdbcType=VARCHAR&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;sex != null&quot;&gt;</span><br><span class="line">        sex = #&#123;sex,jdbcType=VARCHAR&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;birthday != null&quot;&gt;</span><br><span class="line">        birthday = #&#123;birthday,jdbcType=DATE&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;address != null&quot;&gt;</span><br><span class="line">        address = #&#123;address,jdbcType=VARCHAR&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">    &lt;/set&gt;</span><br><span class="line">    where id = #&#123;id,jdbcType=INTEGER&#125;</span><br><span class="line">  &lt;/update&gt;</span><br><span class="line">  &lt;update id=&quot;updateByPrimaryKey&quot; parameterType=&quot;com.soft.pojo.User&quot;&gt;</span><br><span class="line">    update t_user</span><br><span class="line">    set username = #&#123;username,jdbcType=VARCHAR&#125;,</span><br><span class="line">      sex = #&#123;sex,jdbcType=VARCHAR&#125;,</span><br><span class="line">      birthday = #&#123;birthday,jdbcType=DATE&#125;,</span><br><span class="line">      address = #&#123;address,jdbcType=VARCHAR&#125;</span><br><span class="line">    where id = #&#123;id,jdbcType=INTEGER&#125;</span><br><span class="line">  &lt;/update&gt;</span><br><span class="line">  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.soft.pojo.User&quot;&gt;</span><br><span class="line">    &lt;id column=&quot;id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;id&quot; /&gt;</span><br><span class="line">    &lt;result column=&quot;username&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;username&quot; /&gt;</span><br><span class="line">    &lt;result column=&quot;sex&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;sex&quot; /&gt;</span><br><span class="line">    &lt;result column=&quot;birthday&quot; jdbcType=&quot;DATE&quot; property=&quot;birthday&quot; /&gt;</span><br><span class="line">    &lt;result column=&quot;address&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;address&quot; /&gt;</span><br><span class="line">  &lt;/resultMap&gt;</span><br><span class="line">  &lt;sql id=&quot;Base_Column_List&quot;&gt;</span><br><span class="line">    id, username, sex, birthday, address</span><br><span class="line">  &lt;/sql&gt;</span><br><span class="line">  &lt;select id=&quot;selectByPrimaryKey&quot; parameterType=&quot;Integer&quot; resultMap=&quot;BaseResultMap&quot;&gt;</span><br><span class="line">    select </span><br><span class="line">    &lt;include refid=&quot;Base_Column_List&quot; /&gt;</span><br><span class="line">    from t_user</span><br><span class="line">    where id = #&#123;id,jdbcType=INTEGER&#125;</span><br><span class="line">  &lt;/select&gt;</span><br><span class="line">  &lt;delete id=&quot;deleteByPrimaryKey&quot; parameterType=&quot;Integer&quot;&gt;</span><br><span class="line">    delete from t_user</span><br><span class="line">    where id = #&#123;id,jdbcType=INTEGER&#125;</span><br><span class="line">  &lt;/delete&gt;</span><br><span class="line">  &lt;insert id=&quot;insert&quot; parameterType=&quot;com.soft.pojo.User&quot;&gt;</span><br><span class="line">    insert into t_user (id, username, sex, </span><br><span class="line">      birthday, address)</span><br><span class="line">    values (#&#123;id,jdbcType=INTEGER&#125;, #&#123;username,jdbcType=VARCHAR&#125;, #&#123;sex,jdbcType=VARCHAR&#125;, </span><br><span class="line">      #&#123;birthday,jdbcType=DATE&#125;, #&#123;address,jdbcType=VARCHAR&#125;)</span><br><span class="line">  &lt;/insert&gt;</span><br><span class="line">  &lt;insert id=&quot;insertSelective&quot; parameterType=&quot;com.soft.pojo.User&quot;&gt;</span><br><span class="line">    insert into t_user</span><br><span class="line">    &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt;</span><br><span class="line">      &lt;if test=&quot;id != null&quot;&gt;</span><br><span class="line">        id,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;username != null&quot;&gt;</span><br><span class="line">        username,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;sex != null&quot;&gt;</span><br><span class="line">        sex,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;birthday != null&quot;&gt;</span><br><span class="line">        birthday,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;address != null&quot;&gt;</span><br><span class="line">        address,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">    &lt;/trim&gt;</span><br><span class="line">    &lt;trim prefix=&quot;values (&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt;</span><br><span class="line">      &lt;if test=&quot;id != null&quot;&gt;</span><br><span class="line">        #&#123;id,jdbcType=INTEGER&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;username != null&quot;&gt;</span><br><span class="line">        #&#123;username,jdbcType=VARCHAR&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;sex != null&quot;&gt;</span><br><span class="line">        #&#123;sex,jdbcType=VARCHAR&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;birthday != null&quot;&gt;</span><br><span class="line">        #&#123;birthday,jdbcType=DATE&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;address != null&quot;&gt;</span><br><span class="line">        #&#123;address,jdbcType=VARCHAR&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">    &lt;/trim&gt;</span><br><span class="line">  &lt;/insert&gt;</span><br><span class="line">  &lt;update id=&quot;updateByPrimaryKeySelective&quot; parameterType=&quot;com.soft.pojo.User&quot;&gt;</span><br><span class="line">    update t_user</span><br><span class="line">    &lt;set&gt;</span><br><span class="line">      &lt;if test=&quot;username != null&quot;&gt;</span><br><span class="line">        username = #&#123;username,jdbcType=VARCHAR&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;sex != null&quot;&gt;</span><br><span class="line">        sex = #&#123;sex,jdbcType=VARCHAR&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;birthday != null&quot;&gt;</span><br><span class="line">        birthday = #&#123;birthday,jdbcType=DATE&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;address != null&quot;&gt;</span><br><span class="line">        address = #&#123;address,jdbcType=VARCHAR&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">    &lt;/set&gt;</span><br><span class="line">    where id = #&#123;id,jdbcType=INTEGER&#125;</span><br><span class="line">  &lt;/update&gt;</span><br><span class="line">  &lt;update id=&quot;updateByPrimaryKey&quot; parameterType=&quot;com.soft.pojo.User&quot;&gt;</span><br><span class="line">    update t_user</span><br><span class="line">    set username = #&#123;username,jdbcType=VARCHAR&#125;,</span><br><span class="line">      sex = #&#123;sex,jdbcType=VARCHAR&#125;,</span><br><span class="line">      birthday = #&#123;birthday,jdbcType=DATE&#125;,</span><br><span class="line">      address = #&#123;address,jdbcType=VARCHAR&#125;</span><br><span class="line">    where id = #&#123;id,jdbcType=INTEGER&#125;</span><br><span class="line">  &lt;/update&gt;</span><br><span class="line">  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.soft.pojo.User&quot;&gt;</span><br><span class="line">    &lt;id column=&quot;id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;id&quot; /&gt;</span><br><span class="line">    &lt;result column=&quot;username&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;username&quot; /&gt;</span><br><span class="line">    &lt;result column=&quot;sex&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;sex&quot; /&gt;</span><br><span class="line">    &lt;result column=&quot;birthday&quot; jdbcType=&quot;DATE&quot; property=&quot;birthday&quot; /&gt;</span><br><span class="line">    &lt;result column=&quot;address&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;address&quot; /&gt;</span><br><span class="line">  &lt;/resultMap&gt;</span><br><span class="line">  &lt;sql id=&quot;Base_Column_List&quot;&gt;</span><br><span class="line">    id, username, sex, birthday, address</span><br><span class="line">  &lt;/sql&gt;</span><br><span class="line">  &lt;select id=&quot;selectByPrimaryKey&quot; parameterType=&quot;Integer&quot; resultMap=&quot;BaseResultMap&quot;&gt;</span><br><span class="line">    select </span><br><span class="line">    &lt;include refid=&quot;Base_Column_List&quot; /&gt;</span><br><span class="line">    from t_user</span><br><span class="line">    where id = #&#123;id,jdbcType=INTEGER&#125;</span><br><span class="line">  &lt;/select&gt;</span><br><span class="line">  &lt;delete id=&quot;deleteByPrimaryKey&quot; parameterType=&quot;Integer&quot;&gt;</span><br><span class="line">    delete from t_user</span><br><span class="line">    where id = #&#123;id,jdbcType=INTEGER&#125;</span><br><span class="line">  &lt;/delete&gt;</span><br><span class="line">  &lt;insert id=&quot;insert&quot; parameterType=&quot;com.soft.pojo.User&quot;&gt;</span><br><span class="line">    insert into t_user (id, username, sex, </span><br><span class="line">      birthday, address)</span><br><span class="line">    values (#&#123;id,jdbcType=INTEGER&#125;, #&#123;username,jdbcType=VARCHAR&#125;, #&#123;sex,jdbcType=VARCHAR&#125;, </span><br><span class="line">      #&#123;birthday,jdbcType=DATE&#125;, #&#123;address,jdbcType=VARCHAR&#125;)</span><br><span class="line">  &lt;/insert&gt;</span><br><span class="line">  &lt;insert id=&quot;insertSelective&quot; parameterType=&quot;com.soft.pojo.User&quot;&gt;</span><br><span class="line">    insert into t_user</span><br><span class="line">    &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt;</span><br><span class="line">      &lt;if test=&quot;id != null&quot;&gt;</span><br><span class="line">        id,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;username != null&quot;&gt;</span><br><span class="line">        username,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;sex != null&quot;&gt;</span><br><span class="line">        sex,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;birthday != null&quot;&gt;</span><br><span class="line">        birthday,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;address != null&quot;&gt;</span><br><span class="line">        address,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">    &lt;/trim&gt;</span><br><span class="line">    &lt;trim prefix=&quot;values (&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt;</span><br><span class="line">      &lt;if test=&quot;id != null&quot;&gt;</span><br><span class="line">        #&#123;id,jdbcType=INTEGER&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;username != null&quot;&gt;</span><br><span class="line">        #&#123;username,jdbcType=VARCHAR&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;sex != null&quot;&gt;</span><br><span class="line">        #&#123;sex,jdbcType=VARCHAR&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;birthday != null&quot;&gt;</span><br><span class="line">        #&#123;birthday,jdbcType=DATE&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;address != null&quot;&gt;</span><br><span class="line">        #&#123;address,jdbcType=VARCHAR&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">    &lt;/trim&gt;</span><br><span class="line">  &lt;/insert&gt;</span><br><span class="line">  &lt;update id=&quot;updateByPrimaryKeySelective&quot; parameterType=&quot;com.soft.pojo.User&quot;&gt;</span><br><span class="line">    update t_user</span><br><span class="line">    &lt;set&gt;</span><br><span class="line">      &lt;if test=&quot;username != null&quot;&gt;</span><br><span class="line">        username = #&#123;username,jdbcType=VARCHAR&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;sex != null&quot;&gt;</span><br><span class="line">        sex = #&#123;sex,jdbcType=VARCHAR&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;birthday != null&quot;&gt;</span><br><span class="line">        birthday = #&#123;birthday,jdbcType=DATE&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;address != null&quot;&gt;</span><br><span class="line">        address = #&#123;address,jdbcType=VARCHAR&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">    &lt;/set&gt;</span><br><span class="line">    where id = #&#123;id,jdbcType=INTEGER&#125;</span><br><span class="line">  &lt;/update&gt;</span><br><span class="line">  &lt;update id=&quot;updateByPrimaryKey&quot; parameterType=&quot;com.soft.pojo.User&quot;&gt;</span><br><span class="line">    update t_user</span><br><span class="line">    set username = #&#123;username,jdbcType=VARCHAR&#125;,</span><br><span class="line">      sex = #&#123;sex,jdbcType=VARCHAR&#125;,</span><br><span class="line">      birthday = #&#123;birthday,jdbcType=DATE&#125;,</span><br><span class="line">      address = #&#123;address,jdbcType=VARCHAR&#125;</span><br><span class="line">    where id = #&#123;id,jdbcType=INTEGER&#125;</span><br><span class="line">  &lt;/update&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package com.soft.pojo;</span><br><span class="line"></span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class User &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line"></span><br><span class="line">    private String username;</span><br><span class="line"></span><br><span class="line">    private String sex;</span><br><span class="line"></span><br><span class="line">    private Date birthday;</span><br><span class="line"></span><br><span class="line">    private String address;</span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUsername(String username) &#123;</span><br><span class="line">        this.username = username == null ? null : username.trim();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getSex() &#123;</span><br><span class="line">        return sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSex(String sex) &#123;</span><br><span class="line">        this.sex = sex == null ? null : sex.trim();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Date getBirthday() &#123;</span><br><span class="line">        return birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBirthday(Date birthday) &#123;</span><br><span class="line">        this.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getAddress() &#123;</span><br><span class="line">        return address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAddress(String address) &#123;</span><br><span class="line">        this.address = address == null ? null : address.trim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Mybatis-动态SQL"><a href="#Mybatis-动态SQL" class="headerlink" title="Mybatis 动态SQL"></a>Mybatis 动态SQL</h2><ul><li>主要用于解决查询条件不确定的情况：在程序运行的期间，根据提交的查询条件进行查询</li><li>通过Mybatis提供的各种标签对条件作出判断，以实现动态拼接SQL语句</li><li>Mybatis提供的标签有：<ul><li>if</li><li>where</li><li>trim</li><li>set</li><li>foreach</li><li>choose<h3 id="where标签"><a href="#where标签" class="headerlink" title="where标签"></a>where标签</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapper namespace=<span class="string">"com.neuedu.mapper.UserMapper"</span>&gt;</span><br><span class="line">&lt;!-- 用户信息综合查询</span><br><span class="line">#&#123;userCustom.sex&#125;:取出pojo包装对象中性别值</span><br><span class="line">$&#123;userCustom.username&#125;：取出pojo包装对象中用户名称</span><br><span class="line"> --&gt;</span><br><span class="line">&lt;select id=<span class="string">"findUserList"</span> parameterType=<span class="string">"com.neuedu.pojo.UserQueryVo"</span> </span><br><span class="line">resultType=<span class="string">"com.neuedu.pojo.UserCustom"</span>&gt;</span><br><span class="line">SELECT * FROM T_USER</span><br><span class="line">&lt;!-- </span><br><span class="line">where可以自动去掉条件中的第一个and</span><br><span class="line"> --&gt;</span><br><span class="line">&lt;where&gt;</span><br><span class="line">&lt;<span class="keyword">if</span> test=<span class="string">"userCustom!=null"</span>&gt;</span><br><span class="line">&lt;<span class="keyword">if</span> test=<span class="string">"userCustom.sex!=null and userCustom.sex!=''"</span>&gt;</span><br><span class="line">and T_USER.sex = #&#123;userCustom.sex&#125;</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;<span class="keyword">if</span> test=<span class="string">"userCustom.username!=null and userCustom.username!=''"</span>&gt;</span><br><span class="line">and T_USER.username LIKE <span class="string">'%$&#123;userCustom.username&#125;%'</span></span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 用户信息综合查询总数</span><br><span class="line">parameterType：指定输入类型和findUserList一样</span><br><span class="line">resultType：输出结果类型</span><br><span class="line"> --&gt;</span><br><span class="line">&lt;select id=<span class="string">"findUserCount"</span> parameterType=<span class="string">"com.neuedu.pojo.UserQueryVo"</span> resultType=<span class="string">"int"</span>&gt;</span><br><span class="line">   <span class="function">SELECT <span class="title">count</span><span class="params">(*)</span> FROM T_USER </span></span><br><span class="line"><span class="function">  &lt;!-- </span></span><br><span class="line"><span class="function">where可以自动去掉条件中的第一个and</span></span><br><span class="line"><span class="function"> --&gt;</span></span><br><span class="line"><span class="function">&lt;where&gt;</span></span><br><span class="line"><span class="function">&lt;<span class="keyword">if</span> test</span>=<span class="string">"userCustom!=null"</span>&gt;</span><br><span class="line">&lt;<span class="keyword">if</span> test=<span class="string">"userCustom.sex!=null and userCustom.sex!=''"</span>&gt;</span><br><span class="line">and T_USER.sex = #&#123;userCustom.sex&#125;</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;<span class="keyword">if</span> test=<span class="string">"userCustom.username!=null and userCustom.username!=''"</span>&gt;</span><br><span class="line">and T_USER.username LIKE <span class="string">'%$&#123;userCustom.username&#125;%'</span></span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="trim标签"><a href="#trim标签" class="headerlink" title="trim标签"></a>trim标签</h3><ul><li>trim标签的主要功能就是可以在自己包含的内容前加上某些前缀，也可以在其后加上某些后缀，与之对应的属性是prefix和suffix</li><li>trim标签可以把包含的首部某些内容覆盖，也可以把尾部的某些内容覆盖，对应的属性分别是prefixOverrides 和suffixOverrides;<br>*主要用在insert语句上<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=<span class="string">"insertSelective"</span> parameterType=<span class="string">"com.neuedu.pojo.User"</span> &gt;</span><br><span class="line">    insert into T_USER</span><br><span class="line">    &lt;trim prefix=<span class="string">"("</span> suffix=<span class="string">")"</span> suffixOverrides=<span class="string">","</span> &gt;</span><br><span class="line">      &lt;<span class="keyword">if</span> test=<span class="string">"id != null"</span> &gt;</span><br><span class="line">        ID,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;<span class="keyword">if</span> test=<span class="string">"username != null"</span> &gt;</span><br><span class="line">        USERNAME,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;<span class="keyword">if</span> test=<span class="string">"birthday != null"</span> &gt;</span><br><span class="line">        BIRTHDAY,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;<span class="keyword">if</span> test=<span class="string">"sex != null"</span> &gt;</span><br><span class="line">        SEX,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;<span class="keyword">if</span> test=<span class="string">"address != null"</span> &gt;</span><br><span class="line">        ADDRESS,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">    &lt;/trim&gt;</span><br><span class="line">    &lt;trim prefix=<span class="string">"values ("</span> suffix=<span class="string">")"</span> suffixOverrides=<span class="string">","</span> &gt;</span><br><span class="line">      &lt;<span class="keyword">if</span> test=<span class="string">"id != null"</span> &gt;</span><br><span class="line">        #&#123;id,jdbcType=DECIMAL&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;<span class="keyword">if</span> test=<span class="string">"username != null"</span> &gt;</span><br><span class="line">        #&#123;username,jdbcType=VARCHAR&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;<span class="keyword">if</span> test=<span class="string">"birthday != null"</span> &gt;</span><br><span class="line">        #&#123;birthday,jdbcType=DATE&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;<span class="keyword">if</span> test=<span class="string">"sex != null"</span> &gt;</span><br><span class="line">        #&#123;sex,jdbcType=CHAR&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;<span class="keyword">if</span> test=<span class="string">"address != null"</span> &gt;</span><br><span class="line">        #&#123;address,jdbcType=VARCHAR&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">    &lt;/trim&gt;</span><br><span class="line">  &lt;/insert&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="set标签"><a href="#set标签" class="headerlink" title="set标签"></a>set标签</h3><ul><li>set标签主要是用于更新操作</li><li>当update语句中没有使用if标签时，如果有一个参数为null。会导致错误</li><li>即使当update语句中使用if标签时，如果前面的if没有执行会导致有逗号多余的错误</li><li>使用set标签可以在包含的语句前输出一个set，然后如果包含的语句时以逗号结束的话会把该逗号省略</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;update id=<span class="string">"updateUser"</span> parameterType=<span class="string">"user"</span>&gt;</span><br><span class="line">update t_user</span><br><span class="line">&lt;set&gt;</span><br><span class="line">&lt;<span class="keyword">if</span> test=<span class="string">"username !=null and username !=''"</span>&gt;</span><br><span class="line">username = #&#123;username&#125;,</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;<span class="keyword">if</span> test=<span class="string">"birthday != null"</span>&gt;</span><br><span class="line">birthday = #&#123;birthday&#125;,</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;<span class="keyword">if</span> test=<span class="string">"sex != null and sex !=''"</span>&gt;</span><br><span class="line">sex = #&#123;sex&#125;,</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;<span class="keyword">if</span> test=<span class="string">"address != null and address !=''"</span>&gt;</span><br><span class="line">address = #&#123;address&#125;,</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;/set&gt;</span><br><span class="line">where id=#&#123;id&#125;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure><h3 id="foreach标签"><a href="#foreach标签" class="headerlink" title="foreach标签"></a>foreach标签</h3><ul><li>主要用在构建in条件中，它可以在SQL语句中进行迭代一个集合</li><li>foreach标签的属性：<ul><li>item 表示集合中每一个迭代元素</li><li>index 指定迭代的位置</li><li>collection 属性值有三个<ul><li>list 传入的参数为单参数且类型时list</li><li>array 传入的参数为单参数且类型时数组</li><li>“key” 传入的参数为多参数，mybatis将它封装为map,map的key就是参数名</li></ul></li><li>open 表示该语句以什么开始</li><li>seperator 表示在每次进行迭代之间以什么符号作为分隔符</li><li>close 与open相对<br>####单参数list的类型<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserCustom&gt; <span class="title">findUserByForeach1</span><span class="params">(List&lt;Integer&gt; ids)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">"findUserByForeach1"</span>resultType=<span class="string">"UserCustom"</span>&gt;</span><br><span class="line">SELECT * FROM T_USER</span><br><span class="line">&lt;where&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 使用 foreach遍历传入ids</span><br><span class="line">collection：指定输入 对象中集合属性</span><br><span class="line">item：每个遍历生成对象中</span><br><span class="line">open：开始遍历时拼接的串</span><br><span class="line">close：结束遍历时拼接的串</span><br><span class="line">separator：遍历的两个对象中需要拼接的串</span><br><span class="line"> --&gt;</span><br><span class="line"> &lt;!-- 使用实现下边的sql拼接：</span><br><span class="line">  AND (id=<span class="number">1</span> OR id=<span class="number">10</span> OR id=<span class="number">16</span>) </span><br><span class="line">  --&gt;</span><br><span class="line"> &lt;foreach collection=<span class="string">"list"</span> item=<span class="string">"user_id"</span> open=<span class="string">"AND ("</span> close=<span class="string">")"</span> separator=<span class="string">"or"</span>&gt;</span><br><span class="line">&lt;!-- 每个遍历需要拼接的串 --&gt;</span><br><span class="line">id=#&#123;user_id&#125;</span><br><span class="line">&lt;/foreach&gt; </span><br><span class="line"></span><br><span class="line">&lt;!-- 实现  “ <span class="function">and id <span class="title">IN</span><span class="params">(<span class="number">1</span>,<span class="number">10</span>,<span class="number">16</span>)</span>”拼接 --&gt;</span></span><br><span class="line"><span class="function">&lt;!-- &lt;foreach collection</span>=<span class="string">"list"</span> item=<span class="string">"user_id"</span> open=<span class="string">"and id IN("</span> close=<span class="string">")"</span> separator=<span class="string">","</span>&gt;</span><br><span class="line">#&#123;user_id&#125;</span><br><span class="line">&lt;/foreach&gt;  --&gt;</span><br><span class="line"></span><br><span class="line">&lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>####单参数数组的类型<br>与list差不多</p><p>####map的类型 </p><ul><li><p>mapper接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"><span class="comment">//用户信息查询，条件为map类型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserCustom&gt; <span class="title">findUserByForeach3</span><span class="params">(Map&lt;String, Object&gt; params)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>map.xml</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">"findUserByForeach3"</span>resultType=<span class="string">"UserCustom"</span>&gt;</span><br><span class="line">SELECT * FROM T_USER</span><br><span class="line">&lt;where&gt;</span><br><span class="line">T_USER.username LIKE <span class="string">'%$&#123;name&#125;%'</span></span><br><span class="line"> &lt;!-- 使用实现下边的sql拼接：</span><br><span class="line">  AND (id=<span class="number">1</span> OR id=<span class="number">10</span> OR id=<span class="number">16</span>) </span><br><span class="line">  --&gt;</span><br><span class="line">  &lt;foreach collection=<span class="string">"ids"</span> item=<span class="string">"user_id"</span> open=<span class="string">"AND ("</span> close=<span class="string">")"</span> separator=<span class="string">"or"</span>&gt;</span><br><span class="line">&lt;!-- 每个遍历需要拼接的串 --&gt;</span><br><span class="line">id=#&#123;user_id&#125;</span><br><span class="line">&lt;/foreach&gt;  </span><br><span class="line"></span><br><span class="line">&lt;!-- 实现  “ <span class="function">and id <span class="title">IN</span><span class="params">(<span class="number">1</span>,<span class="number">10</span>,<span class="number">16</span>)</span>”拼接 --&gt;</span></span><br><span class="line"><span class="function">&lt;!--  &lt;foreach collection</span>=<span class="string">"ids"</span> item=<span class="string">"user_id"</span> open=<span class="string">"and id IN("</span> close=<span class="string">")"</span> separator=<span class="string">","</span>&gt;</span><br><span class="line">#&#123;user_id&#125;</span><br><span class="line">&lt;/foreach&gt;  --&gt;</span><br><span class="line"></span><br><span class="line">&lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testFindUserByForeach3() throws Exception &#123;</span><br><span class="line">SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">//创建UserMapper对象，mybatis自动生成mapper代理对象</span><br><span class="line">UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">//创建Map对象，设置查询条件,传入多个id</span><br><span class="line">Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">        map.put(&quot;name&quot;, &quot;小军&quot;);</span><br><span class="line">        map.put(&quot;ids&quot;, new int[]&#123;1,206,207&#125;);                </span><br><span class="line">//调用userMapper的方法</span><br><span class="line">List&lt;UserCustom&gt; list = userMapper.findUserByForeach3(map);</span><br><span class="line"></span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="choose标签"><a href="#choose标签" class="headerlink" title="choose标签"></a>choose标签</h3><ul><li>类似与Java中的switch···case语句，choose为switch，when为case，otherwise为default</li><li>实例：查询默认性别为男的用户<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 多条件查询用户，默认查询性别为男，即sex=1 --&gt;</span><br><span class="line">&lt;select id=&quot;findUserByChoose&quot; parameterType=&quot;UserQueryVo&quot; resultType=&quot;UserCustom&quot;&gt;</span><br><span class="line">        select * from T_USER where 1 = 1</span><br><span class="line">        &lt;choose&gt;</span><br><span class="line">            &lt;when test=&quot;userCustom.username !=null and userCustom.username !=&apos;&apos; &quot;&gt;</span><br><span class="line">                and username LIKE &apos;%$&#123;userCustom.username&#125;%&apos;</span><br><span class="line">            &lt;/when&gt;</span><br><span class="line">            &lt;when test=&quot;userCustom.sex != null and userCustom.sex !=&apos;&apos;&quot;&gt;</span><br><span class="line">                and sex = #&#123;userCustom.sex&#125;</span><br><span class="line">            &lt;/when&gt;</span><br><span class="line">            &lt;otherwise&gt;</span><br><span class="line">                and sex = &apos;1&apos;</span><br><span class="line">            &lt;/otherwise&gt;</span><br><span class="line">        &lt;/choose&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Mybatis-SQL片段"><a href="#Mybatis-SQL片段" class="headerlink" title="Mybatis SQL片段"></a>Mybatis SQL片段</h2><ul><li>在实际开发中，存在大量 的重复的SQL代码，通过SQL代码片段实现SQL代码的重要用</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapper namespace=<span class="string">"com.neuedu.mapper.UserMapper"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 定义sql片段</span><br><span class="line">id：sql片段的唯 一标识</span><br><span class="line"></span><br><span class="line">经验：是基于单表来定义sql片段，这样话这个sql片段可重用性才高</span><br><span class="line">在sql片段中不要包括 where</span><br><span class="line"> --&gt;</span><br><span class="line">&lt;sql id=<span class="string">"query_user_where"</span>&gt;</span><br><span class="line">&lt;<span class="keyword">if</span> test=<span class="string">"userCustom!=null"</span>&gt;</span><br><span class="line">&lt;<span class="keyword">if</span> test=<span class="string">"userCustom.sex!=null and userCustom.sex!=''"</span>&gt;</span><br><span class="line">and T_USER.sex = #&#123;userCustom.sex&#125;</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;<span class="keyword">if</span> test=<span class="string">"userCustom.username!=null and userCustom.username!=''"</span>&gt;</span><br><span class="line">and T_USER.username LIKE <span class="string">'%$&#123;userCustom.username&#125;%'</span></span><br><span class="line">&lt;/if&gt;</span><br><span class="line"></span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;/sql&gt;</span><br><span class="line">&lt;!-- 用户信息综合查询</span><br><span class="line">#&#123;userCustom.sex&#125;:取出pojo包装对象中性别值</span><br><span class="line">$&#123;userCustom.username&#125;：取出pojo包装对象中用户名称</span><br><span class="line"> --&gt;</span><br><span class="line">&lt;select id=<span class="string">"findUserList"</span> parameterType=<span class="string">"com.neuedu.pojo.UserQueryVo"</span> </span><br><span class="line">resultType=<span class="string">"com.neuedu.pojo.UserCustom"</span>&gt;</span><br><span class="line">SELECT * FROM T_USER</span><br><span class="line">&lt;!-- </span><br><span class="line">where可以自动去掉条件中的第一个and</span><br><span class="line"> --&gt;</span><br><span class="line">&lt;where&gt;</span><br><span class="line">&lt;!-- 引用sql片段 的id，如果refid指定的id不在本mapper文件中，需要前边加namespace --&gt;</span><br><span class="line">&lt;include refid="query_user_where"&gt;&lt;/include&gt;</span><br><span class="line">&lt;!-- 在这里还要引用其它的sql片段  --&gt;</span><br><span class="line">&lt;/where&gt;</span><br><span class="line"></span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 用户信息综合查询总数</span><br><span class="line">parameterType：指定输入类型和findUserList一样</span><br><span class="line">resultType：输出结果类型</span><br><span class="line"> --&gt;</span><br><span class="line">&lt;select id=<span class="string">"findUserCount"</span> parameterType=<span class="string">"com.neuedu.pojo.UserQueryVo"</span> resultType=<span class="string">"int"</span>&gt;</span><br><span class="line">   <span class="function">SELECT <span class="title">count</span><span class="params">(*)</span> FROM T_USER </span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function">  &lt;!-- </span></span><br><span class="line"><span class="function">where可以自动去掉条件中的第一个and</span></span><br><span class="line"><span class="function"> --&gt;</span></span><br><span class="line"><span class="function">&lt;where&gt;</span></span><br><span class="line"><span class="function">&lt;!-- 引用sql片段 的id，如果refid指定的id不在本mapper文件中，需要前边加namespace --&gt;</span></span><br><span class="line">&lt;include refid="query_user_where"&gt;&lt;/include&gt;</span><br><span class="line">&lt;!-- 在这里还要引用其它的sql片段  --&gt;</span><br><span class="line">&lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><h2 id="Mybatis关联查询"><a href="#Mybatis关联查询" class="headerlink" title="Mybatis关联查询"></a>Mybatis关联查询</h2><p>Mybatis查询使用select映射的时候的返回值类型有两种</p><ul><li>resultType ：对应模型类的实体</li><li>resultMap：key-value关系</li></ul><h3 id="一对一查询"><a href="#一对一查询" class="headerlink" title="一对一查询"></a>一对一查询</h3><p>实例：查询所有的订单和用户的信息<br>涉及的表：用户表和订单表</p><h4 id="实现方式：returnType"><a href="#实现方式：returnType" class="headerlink" title="实现方式：returnType"></a>实现方式：returnType</h4><p>步骤1：<br>将上边sql查询的结果映射到pojo中，pojo中必须包括所有查询列名。<br>原始的Orders.java不能映射全部字段，需要新创建的pojo。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrdersCustom</span> <span class="keyword">extends</span> <span class="title">Orders</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String sex;</span><br><span class="line"><span class="keyword">private</span> String address;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> username;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.username = username;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> address;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.address = address;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>步骤2：配置OrdersMapCustom.xml文件<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">"findOrdersResultType"</span>resultType=<span class="string">"com.neuedu.pojo.OrdersCustom"</span>&gt;</span><br><span class="line">SELECT</span><br><span class="line">orders.*,</span><br><span class="line">T_USER.username,</span><br><span class="line">T_USER.sex,</span><br><span class="line">T_USER.address</span><br><span class="line">FROM</span><br><span class="line">orders,</span><br><span class="line">T_USER</span><br><span class="line">WHERE orders.user_id = T_USER.id</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p><p>步骤3：:配置OrdersMapCustom.xml文件中select的映射<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">"findOrdersResultType"</span> resultType=<span class="string">"com.neuedu.pojo.OrdersCustom"</span>&gt;</span><br><span class="line">SELECT</span><br><span class="line">orders.*,</span><br><span class="line">T_USER.username,</span><br><span class="line">T_USER.sex,</span><br><span class="line">T_USER.address</span><br><span class="line">FROM</span><br><span class="line">orders,</span><br><span class="line">T_USER</span><br><span class="line">WHERE orders.user_id = T_USER.id</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p><p>步骤4：定义OrdersMapperCustom接口方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrdersMapperCustom</span> </span>&#123;</span><br><span class="line"><span class="comment">//查询订单关联查询用户信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;OrdersCustom&gt; <span class="title">findOrdersResultType</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式：returnMap"><a href="#实现方式：returnMap" class="headerlink" title="实现方式：returnMap"></a>实现方式：returnMap</h4><p>使用resultMap将查询结果中的订单信息映射到Orders对象中，在orders类中添加User属性，将关联查询出来的用户信息映射到orders对象中的user属性中。</p><p>步骤1：创建POJO :User和Orders<br>步骤2：配置OrdersMapCustom.xml文件中resultMap的映射<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap type=<span class="string">"com.neuedu.pojo.Orders"</span> id=<span class="string">"OrdersUserResultMap"</span>&gt;</span><br><span class="line">&lt;!-- 配置映射的订单信息 --&gt;</span><br><span class="line">&lt;!-- id：指定查询列中的唯 一标识，订单信息的中的唯 一标识，如果有多个列组成唯一标识，配置多个id</span><br><span class="line">column：订单信息的唯 一标识 列</span><br><span class="line">property：订单信息的唯 一标识 列所映射到Orders中哪个属性</span><br><span class="line">  --&gt;</span><br><span class="line">&lt;id column=<span class="string">"id"</span> property=<span class="string">"id"</span>/&gt;</span><br><span class="line">&lt;result column=<span class="string">"user_id"</span> property=<span class="string">"userId"</span>/&gt;</span><br><span class="line">&lt;result column=<span class="string">"orderid"</span> property=<span class="string">"orderId"</span>/&gt;</span><br><span class="line">&lt;result column=<span class="string">"createtime"</span> property=<span class="string">"createtime"</span>/&gt;</span><br><span class="line">&lt;result column=<span class="string">"note"</span> property=<span class="string">"note"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置映射的关联的用户信息 --&gt;</span><br><span class="line">&lt;!-- association：用于映射关联查询单个对象的信息</span><br><span class="line">property：要将关联查询的用户信息映射到Orders中哪个属性</span><br><span class="line">javaType：表示关联查询的结果类型</span><br><span class="line"> --&gt;</span><br><span class="line">&lt;association property=<span class="string">"user"</span>  javaType=<span class="string">"com.neuedu.pojo.User"</span>&gt;</span><br><span class="line">&lt;!-- id：关联查询用户的唯 一标识</span><br><span class="line">column：指定唯 一标识用户信息的列</span><br><span class="line">property：映射到user的哪个属性</span><br><span class="line"> --&gt;</span><br><span class="line">&lt;id column=<span class="string">"user_id"</span> property=<span class="string">"id"</span>/&gt;</span><br><span class="line">&lt;result column=<span class="string">"username"</span> property=<span class="string">"username"</span>/&gt;</span><br><span class="line">&lt;result column=<span class="string">"sex"</span> property=<span class="string">"sex"</span>/&gt;</span><br><span class="line">&lt;result column=<span class="string">"address"</span> property=<span class="string">"address"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/association&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure></p><p>步骤3:配置OrdersMapCustom.xml文件中select的映射<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 查询订单关联查询用户信息 --&gt;</span><br><span class="line">&lt;select id=<span class="string">"findOrdersUserResultMap"</span> resultMap=<span class="string">"OrdersUserResultMap"</span>&gt;</span><br><span class="line">    SELECT</span><br><span class="line">    orders.*,</span><br><span class="line">    user.username,</span><br><span class="line">    user.sex,</span><br><span class="line">    user.address</span><br><span class="line">    FROM</span><br><span class="line">    orders,</span><br><span class="line">    user</span><br><span class="line">    WHERE orders.user_id = user.id</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p><p>步骤4:定义OrdersMapperCustom接口方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrdersMapperCustom</span> </span>&#123;</span><br><span class="line"><span class="comment">//查询订单关联查询用户使用resultMap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Orders&gt; <span class="title">findOrdersUserResultMap</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="一对多查询"><a href="#一对多查询" class="headerlink" title="一对多查询"></a>一对多查询</h3><p>实例：查询订单及订单明细的信息；<br>涉及的表：用户表，订单表 ，订单明细表；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">  orders.*,</span><br><span class="line">  user.username,</span><br><span class="line">  user.sex,</span><br><span class="line">  user.address,</span><br><span class="line">  orderdetail.id orderdetail_id,</span><br><span class="line">  orderdetail.items_id,</span><br><span class="line">  orderdetail.items_num,</span><br><span class="line">  orderdetail.orders_id</span><br><span class="line">FROM</span><br><span class="line">  orders,</span><br><span class="line">  user,</span><br><span class="line">  orderdetail</span><br><span class="line">WHERE orders.user_id = user.id AND orderdetail.orders_id=orders.id</span><br></pre></td></tr></table></figure><p>步骤1：创建POJO: User, Orders, OrderDetail<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Orders</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String orderId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date createtime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String note;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用户信息</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//订单明细</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Orderdetail&gt; orderdetails;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *省略了set get方法</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Orderdetail</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer ordersId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer itemsId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer itemsNum;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *省略了set get方法</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Orderdetail [id="</span> + id + <span class="string">", ordersId="</span> + ordersId</span><br><span class="line">+ <span class="string">", itemsId="</span> + itemsId + <span class="string">", itemsNum="</span> + itemsNum + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤2：配置OrdersMapCustom.xml文件中resultMap的映射</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap type=<span class="string">"com.neuedu.pojo.Orders"</span> id=<span class="string">"OrdersAndOrderDetailResultMap"</span> extends=<span class="string">"OrdersUserResultMap"</span>&gt;</span><br><span class="line">&lt;!-- 订单信息 --&gt;</span><br><span class="line">&lt;!-- 用户信息 --&gt;</span><br><span class="line">&lt;!-- 使用extends继承，不用在中配置订单信息和用户信息的映射 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 订单明细信息</span><br><span class="line">一个订单关联查询出了多条明细，要使用collection进行映射</span><br><span class="line">collection：对关联查询到多条记录映射到集合对象中</span><br><span class="line">property：将关联查询到多条记录映射到com.neuedu.pojo.Orders哪个属性</span><br><span class="line">ofType：指定映射到list集合属性中pojo的类型</span><br><span class="line"> --&gt;</span><br><span class="line"> &lt;collection property=<span class="string">"orderdetails"</span> ofType=<span class="string">"com.neuedu.pojo.Orderdetail"</span>&gt;</span><br><span class="line"> &lt;!-- id：订单明细唯 一标识</span><br><span class="line"> property:要将订单明细的唯 一标识 映射到com.neuedu.pojo.Orderdetail的哪个属性</span><br><span class="line">   --&gt;</span><br><span class="line"> &lt;id column=<span class="string">"orderdetail_id"</span> property=<span class="string">"id"</span>/&gt;</span><br><span class="line"> &lt;result column=<span class="string">"items_id"</span> property=<span class="string">"itemsId"</span>/&gt;</span><br><span class="line"> &lt;result column=<span class="string">"items_num"</span> property=<span class="string">"itemsNum"</span>/&gt;</span><br><span class="line"> &lt;result column=<span class="string">"orders_id"</span> property=<span class="string">"ordersId"</span>/&gt;</span><br><span class="line"> &lt;/collection&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure><p>步骤3：配置OrdersMapCustom.xml文件中select的映射<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">"findOrdersAndOrderDetailResultMap"</span> resultMap=<span class="string">"OrdersAndOrderDetailResultMap"</span>&gt;</span><br><span class="line">SELECT </span><br><span class="line">  orders.*,</span><br><span class="line">  T_USER.username,</span><br><span class="line">  T_USER.sex,</span><br><span class="line">  T_USER.address,</span><br><span class="line">  orderdetail.id orderdetail_id,</span><br><span class="line">  orderdetail.items_id,</span><br><span class="line">  orderdetail.items_num,</span><br><span class="line">  orderdetail.orders_id</span><br><span class="line">FROM</span><br><span class="line">  orders,</span><br><span class="line">  T_USER,</span><br><span class="line">  orderdetail</span><br><span class="line">WHERE orders.user_id = T_USER.id AND orderdetail.orders_id=orders.id</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p><p>步骤4：定义OrdersMapCustom的接口方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrdersMapperCustom</span> </span>&#123;</span><br><span class="line"><span class="comment">//查询订单(关联用户)及订单明细</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Orders&gt;  <span class="title">findOrdersAndOrderDetailResultMap</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>小结</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mybatis使用resultMap的collection对关联查询的多条记录映射到一个list集合属性中。</span><br><span class="line">使用resultType实现：将订单明细映射到orders中的orderdetails中，需要自己处理，使用双重循环遍历，去掉重复记录，将订单明细放在orderdetails中。</span><br></pre></td></tr></table></figure><h3 id="多对多查询"><a href="#多对多查询" class="headerlink" title="多对多查询"></a>多对多查询</h3><p>实例：查询用户及用户购买商品信息。<br>涉及的表：用户表，订单表，商品明细表，商品表。<br>思路：<br>    将用户信息映射到user中。</p><pre><code>在user类中添加订单列表属性List&lt;Orders&gt; orderslist，将用户创建的订单映射到orderslist在Orders中添加订单明细列表属性List&lt;OrderDetail&gt;orderdetials，将订单的明细映射到orderdetials在OrderDetail中添加Items属性，将订单明细所对应的商品映射到Items</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">  orders.*,</span><br><span class="line">  user.username,</span><br><span class="line">  user.sex,</span><br><span class="line">  user.address,</span><br><span class="line">  orderdetail.id orderdetail_id,</span><br><span class="line">  orderdetail.items_id,</span><br><span class="line">  orderdetail.items_num,</span><br><span class="line">  orderdetail.orders_id,</span><br><span class="line">  items.name items_name,</span><br><span class="line">  items.detail items_detail,</span><br><span class="line">  items.price items_price</span><br><span class="line">FROM</span><br><span class="line">  orders,</span><br><span class="line">  user,</span><br><span class="line">  orderdetail,</span><br><span class="line">  items</span><br><span class="line">WHERE orders.user_id = user.id AND orderdetail.orders_id=orders.id AND orderdetail.items_id = items.id</span><br></pre></td></tr></table></figure><p>步骤1：POJO创建<br>用户类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//属性名和数据库表的字段对应</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String username;<span class="comment">// 用户姓名</span></span><br><span class="line"><span class="keyword">private</span> String sex;<span class="comment">// 性别</span></span><br><span class="line"><span class="keyword">private</span> Date birthday;<span class="comment">// 生日</span></span><br><span class="line"><span class="keyword">private</span> String address;<span class="comment">// 地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用户创建的订单列表</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Orders&gt; ordersList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*省略了get set方法</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>订单类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Orders</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String orderId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date createtime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String note;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用户信息</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//订单明细</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Orderdetail&gt; orderdetails;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *省略了set get方法</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>商品明细类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Orderdetail</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer ordersId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer itemsId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer itemsNum;</span><br><span class="line">     <span class="comment">//明细对应的商品信息</span></span><br><span class="line">    <span class="keyword">private</span> Items items;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *省略了set get方法</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Orderdetail [id="</span> + id + <span class="string">", ordersId="</span> + ordersId</span><br><span class="line">+ <span class="string">", itemsId="</span> + itemsId + <span class="string">", itemsNum="</span> + itemsNum + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>商品类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Items</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Float price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String pic;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date createtime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String detail;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *省略了set get方法</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>步骤2：配置OrdersMapCustom.xml文件中resultMap的映射<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap type=<span class="string">"com.neuedu.pojo.User"</span> id=<span class="string">"UserAndItemsResultMap"</span>&gt;</span><br><span class="line">&lt;!-- 用户信息 --&gt;</span><br><span class="line">&lt;id column=<span class="string">"user_id"</span> property=<span class="string">"id"</span>/&gt;</span><br><span class="line">&lt;result column=<span class="string">"username"</span> property=<span class="string">"username"</span>/&gt;</span><br><span class="line">&lt;result column=<span class="string">"sex"</span> property=<span class="string">"sex"</span>/&gt;</span><br><span class="line">&lt;result column=<span class="string">"address"</span> property=<span class="string">"address"</span>/&gt;</span><br><span class="line">&lt;!-- 订单信息一个用户对应多个订单，使用collection映射 --&gt;</span><br><span class="line"> &lt;collection property=<span class="string">"ordersList"</span> ofType=<span class="string">"com.neuedu.pojo.Orders"</span>&gt;</span><br><span class="line"> &lt;id column=<span class="string">"id"</span> property=<span class="string">"id"</span>/&gt;</span><br><span class="line"> &lt;result column=<span class="string">"user_id"</span> property=<span class="string">"userId"</span>/&gt;</span><br><span class="line">&lt;result column=<span class="string">"number"</span> property=<span class="string">"number"</span>/&gt;</span><br><span class="line">&lt;result column=<span class="string">"createtime"</span> property=<span class="string">"createtime"</span>/&gt;</span><br><span class="line">&lt;result column=<span class="string">"note"</span> property=<span class="string">"note"</span>/&gt;</span><br><span class="line"> &lt;!-- 订单明细 一个订单包括 多个明细  --&gt;</span><br><span class="line">  &lt;collection property=<span class="string">"orderdetails"</span> ofType=<span class="string">"com.neuedu.pojo.Orderdetail"</span>&gt;</span><br><span class="line">  &lt;id column=<span class="string">"orderdetail_id"</span> property=<span class="string">"id"</span>/&gt;</span><br><span class="line"> &lt;result column=<span class="string">"items_id"</span> property=<span class="string">"itemsId"</span>/&gt;</span><br><span class="line"> &lt;result column=<span class="string">"items_num"</span> property=<span class="string">"itemsNum"</span>/&gt;</span><br><span class="line"> &lt;result column=<span class="string">"orders_id"</span> property=<span class="string">"ordersId"</span>/&gt;</span><br><span class="line"> &lt;!-- 商品信息一个订单明细对应一个商品   --&gt;</span><br><span class="line">   &lt;association property=<span class="string">"items"</span> javaType=<span class="string">"com.neuedu.pojo.Items"</span>&gt;</span><br><span class="line">   &lt;id column=<span class="string">"items_id"</span> property=<span class="string">"id"</span>/&gt;</span><br><span class="line">   &lt;result column=<span class="string">"items_name"</span> property=<span class="string">"name"</span>/&gt;</span><br><span class="line">   &lt;result column=<span class="string">"items_detail"</span> property=<span class="string">"detail"</span>/&gt;</span><br><span class="line">   &lt;result column=<span class="string">"items_price"</span> property=<span class="string">"price"</span>/&gt;</span><br><span class="line">   &lt;/association&gt;</span><br><span class="line">  &lt;/collection&gt;</span><br><span class="line"> &lt;/collection&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure></p><p>步骤3：配置OrdersMapCustom.xml文件中select的映射<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 查询用户及购买的商品信息，使用resultmap --&gt;</span><br><span class="line">&lt;select id=<span class="string">"findUserAndItemsResultMap"</span> resultMap=<span class="string">"UserAndItemsResultMap"</span>&gt;</span><br><span class="line">SELECT </span><br><span class="line">  orders.*,</span><br><span class="line">  USERINFO.username,</span><br><span class="line">  USERINFO.sex,</span><br><span class="line">  USERINFO.address,</span><br><span class="line">  orderdetail.id orderdetail_id,</span><br><span class="line">  orderdetail.items_id,</span><br><span class="line">  orderdetail.items_num,</span><br><span class="line">  orderdetail.orders_id,</span><br><span class="line">  items.name items_name,</span><br><span class="line">  items.detail items_detail,</span><br><span class="line">  items.price items_price</span><br><span class="line">FROM</span><br><span class="line">  orders,</span><br><span class="line">  USERINFO,</span><br><span class="line">  orderdetail,</span><br><span class="line">  items</span><br><span class="line">WHERE orders.user_id = userinfo.id AND orderdetail.orders_id=orders.id AND orderdetail.items_id = items.id</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p><p>步骤4：定义OrdersMapCustom的接口方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrdersMapperCustom</span> </span>&#123;</span><br><span class="line"><span class="comment">//查询用户购买商品信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt;  <span class="title">findUserAndItemsResultMap</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringMVC</title>
      <link href="/2018/07/27/SpringMVC/"/>
      <url>/2018/07/27/SpringMVC/</url>
      
        <content type="html"><![CDATA[<p>springMVC分离了控制器、模型对象、过滤器以及处理程序对象的角色<br><a id="more"></a><br><img src="/2018/07/27/SpringMVC/springmvc_核心架构图.jpg" title="springmvc核心架构图"></p><h2 id="简述SpringMVC工作流程"><a href="#简述SpringMVC工作流程" class="headerlink" title="简述SpringMVC工作流程"></a>简述SpringMVC工作流程</h2><p>一个springMVC项目的结构<br><img src="/2018/07/27/SpringMVC/项目结构.png" title="webapp"><br>web.xml是项目的入口<br><img src="/2018/07/27/SpringMVC/webxml.png" title="web.xml"><br>DispatcherServlet是前置控制器，配置在web.xml文件中的。拦截匹配的请求，Servlet拦截匹配规则要自已定义，把拦截下来的请求，依据相应的规则分发到目标Controller来处理，是配置spring MVC的第一步。<br><img src="/2018/07/27/SpringMVC/springmvcxml.png" title="springmvc.xml"><br>工作流程：</p><p>启动tomcat，程序开始运行，进入index.jsp页面，点击在该页面的如下链接，之后进入程序中的找到相应的controller，controller处理好数据之后，将视图转到/WEB-INF/jsp/items/itemsList.jsp，之后将这个页面显示在浏览器url为/queryItems.action下；即/queryItems.action就是/WEB-INF/jsp/items/itemsList.jsp    （在WEB-INF目录下的文件不能直接利用url进行访问）<br><img src="/2018/07/27/SpringMVC/controller.png" title="ItemsController.java"></p><pre><code>@Controller 负责注册一个bean 到spring 上下文中@RequestMapping 注解为控制器指定可以处理哪些 URL 请求</code></pre><h2 id="SpringMVC处理器映射器"><a href="#SpringMVC处理器映射器" class="headerlink" title="SpringMVC处理器映射器"></a>SpringMVC处理器映射器</h2><p>处理器映射器（HandlerMapping），负责根据request请求找到对应的Handler处理器及Interceptor拦截器，将它们封装在HandlerExecutionChain对象中给前端控制器返回</p><h3 id="注解的HandlerMapping"><a href="#注解的HandlerMapping" class="headerlink" title="注解的HandlerMapping"></a>注解的HandlerMapping</h3><p>在类中标记@RequestMapping，根据RequestMapping中的URL匹配RequestMapping标记的方法，匹配成功返回HandleMethod对象给前端控制器，HandleMethod对象封装URL对应的方法</p><h2 id="SpringMVC处理器适配器"><a href="#SpringMVC处理器适配器" class="headerlink" title="SpringMVC处理器适配器"></a>SpringMVC处理器适配器</h2><p>处理器适配器（HandlerAdapter），HandlerAdapter会根据适配器接口对后端控制器进行包装（适配），包装后即可对处理器进行执行，通过扩展处理器适配器可以执行多种类型的处理器，这里使用了适配器设计模式。</p><h3 id="注解的HandlerAdapter"><a href="#注解的HandlerAdapter" class="headerlink" title="注解的HandlerAdapter"></a>注解的HandlerAdapter</h3><p>对标记@ResquestMapping的方法进行适配</p><h2 id="映射请求"><a href="#映射请求" class="headerlink" title="映射请求"></a>映射请求</h2><h3 id="RequestMapping修饰类与方法"><a href="#RequestMapping修饰类与方法" class="headerlink" title="@RequestMapping修饰类与方法"></a>@RequestMapping修饰类与方法</h3><p>Spring MVC 使用 @RequestMapping 注解为控制器指定可以处理哪些 URL 请求，<br>在 <strong>控制器的类定义</strong> 及 <strong>方法定义</strong> 处都可标注。</p><ul><li>修饰类：提供初步的请求映射信息。相对于 WEB 应用的根目录</li><li>修饰方法：提供进一步的细分映射信息。相对于类定义处的 URL。若类定义处未标注 @RequestMapping，则方法处标记的 URL 相对于WEB 应用的根目录<br>DispatcherServlet 截获请求后，就通过控制器上@RequestMapping 提供的映射信息确定请求所对应的处理方法。<img src="/2018/07/27/SpringMVC/requestMapping修饰类.png" title="例子"><h3 id="RequestMapping修饰方法时的参数"><a href="#RequestMapping修饰方法时的参数" class="headerlink" title="@RequestMapping修饰方法时的参数"></a>@RequestMapping修饰方法时的参数</h3>@RequestMapping (value=” “,   method=” “,params=” “, headers=” “)<br>value、method、params 及 headers 分别表示请求 URL，请求方法，请求参数及请求头的映射条件<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/editItemsSubmit"</span>,params=&#123;<span class="string">"name"</span>,<span class="string">"price"</span>&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">editItemsSubmit</span><span class="params">(<span class="keyword">int</span> id,String name,<span class="keyword">float</span> price)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">itemsService.updateItems(id, itemsCustom);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"name="</span>+name);</span><br><span class="line">System.out.println(<span class="string">"price="</span>+price);</span><br><span class="line">ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView();</span><br><span class="line"></span><br><span class="line">modelAndView.setViewName(<span class="string">"success"</span>);</span><br><span class="line"><span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="controller方法的返回值"><a href="#controller方法的返回值" class="headerlink" title="controller方法的返回值"></a>controller方法的返回值</h2><ul><li>返回ModelAndView</li><li>返回字符串</li><li>返回void</li></ul><h3 id="返回ModelView"><a href="#返回ModelView" class="headerlink" title="返回ModelView"></a>返回ModelView</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/queryItems"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">queryItems</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用service查找 数据库，查询商品列表</span></span><br><span class="line">List&lt;ItemsCustom&gt; itemsList = <span class="keyword">new</span> ArrayList&lt;ItemsCustom&gt;();</span><br><span class="line">itemsList = itemsService.findItemsList(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回ModelAndView</span></span><br><span class="line">ModelAndView modelAndView =  <span class="keyword">new</span> ModelAndView();</span><br><span class="line"><span class="comment">//相当 于request的setAttribute，在jsp页面中通过itemsList取数据</span></span><br><span class="line">modelAndView.addObject(<span class="string">"itemsList"</span>, itemsList);</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定视图</span></span><br><span class="line">modelAndView.setViewName(<span class="string">"items/itemsList"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回字符串"><a href="#返回字符串" class="headerlink" title="返回字符串"></a>返回字符串</h3><p>返回字符串时，有三种含义：</p><ul><li>表示返回逻辑视图名</li><li>redirect重定向</li><li>forward页面转发</li></ul><p>返回字符串时，如果涉及到数据的传递时，处理器形参中添加如下类型的参数，处理适配器会默认识别并进行赋值：</p><ul><li>HttpServletRequest<br>   通过request对象获取请求信息</li><li>HttpSession<br>通过session对象得到session中存放的对象</li><li>Model/ModelMap<br>ModelMap是Model接口的实现类，将model数据填充到request域，向页面传递数据</li></ul><h4 id="返回逻辑视图名"><a href="#返回逻辑视图名" class="headerlink" title="返回逻辑视图名"></a>返回逻辑视图名</h4><p>真正视图（JSP逻辑路径）是：前缀+逻辑视图名+后缀名<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>-用request存放数据</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/editItems"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">editItems</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ItemsCustom itemsCustom = itemsService.findItemsById(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//将数据保存到request中，在jsp页面中通过itemsCustom取数据</span></span><br><span class="line">request.setAttribute(<span class="string">"itemsCustom"</span>, itemsCustom);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"/items/editItems"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>-用model存放数据</span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/editItems"</span>,method=&#123;RequestMethod.GET,RequestMethod.POST&#125; )</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">editItems</span><span class="params">(Model model)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ItemsCustom itemsCustom = itemsService.findItemsById(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//将数据保存到request中，在jsp页面中通过itemsCustom取数据</span></span><br><span class="line">model.addAttribute(<span class="string">"itemsCustom"</span>, itemsCustom);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"/items/editItems"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="redirect重定向"><a href="#redirect重定向" class="headerlink" title="redirect重定向"></a>redirect重定向</h4><p>redirect重定向特点：<br><strong>浏览器地址栏中的url会变化。修改提交的request数据无法传到重定向的地址。因为重定向后重新进行request（request无法共享）。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/editItemsSubmit"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">editItemsSubmit</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"redirect:queryItems.action"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="forward页面转发"><a href="#forward页面转发" class="headerlink" title="forward页面转发"></a>forward页面转发</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/editItemsSubmit"</span>)</span><br><span class="line"><span class="comment">//controller方法返回string,请求转发</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">editItemsSubmit</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"forward:queryItems.action"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回void"><a href="#返回void" class="headerlink" title="返回void"></a>返回void</h3><p>当返回void时，在controller方法形参上可以定义request和response，使用request或response指定响应结果：</p><ul><li>使用request转向页面，如下：<br>request.getRequestDispatcher(“页面路径”).forward(request, response);</li><li>使用response页面重定向：<br>response.sendRedirect(“url”)</li><li>使用response指定响应结果，例如响应json数据如下：<br>response.setCharacterEncoding(“utf-8”);<br>response.setContentType(“application/json;charset=utf-8”);<br>response.getWriter().write(“json串”);</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用service查找 数据库，查询商品列表，这里使用静态数据模拟</span></span><br><span class="line">List&lt;Items&gt; itemsList = <span class="keyword">new</span> ArrayList&lt;Items&gt;();</span><br><span class="line"><span class="comment">//向list中填充静态数据</span></span><br><span class="line"></span><br><span class="line">Items items_1 = <span class="keyword">new</span> Items();</span><br><span class="line">items_1.setName(<span class="string">"联想笔记本"</span>);</span><br><span class="line">items_1.setPrice(<span class="number">6000f</span>);</span><br><span class="line">items_1.setDetail(<span class="string">"ThinkPad T430 联想笔记本电脑！"</span>);</span><br><span class="line"></span><br><span class="line">Items items_2 = <span class="keyword">new</span> Items();</span><br><span class="line">items_2.setName(<span class="string">"苹果手机"</span>);</span><br><span class="line">items_2.setPrice(<span class="number">5000f</span>);</span><br><span class="line">items_2.setDetail(<span class="string">"iphone6苹果手机！"</span>);</span><br><span class="line"></span><br><span class="line">itemsList.add(items_1);</span><br><span class="line">itemsList.add(items_2);</span><br><span class="line">request.setAttribute(<span class="string">"itemsList"</span>, itemsList);</span><br><span class="line">request.getRequestDispatcher(<span class="string">"/WEB-INF/jsp/items/itemsList.jsp"</span>).forward(request, response);</span><br><span class="line"></span><br><span class="line"><span class="comment">////返回json数据</span></span><br><span class="line"><span class="comment">//response.setCharacterEncoding("utf-8");</span></span><br><span class="line"><span class="comment">//response.setContentType("application/json;charset=utf-8");</span></span><br><span class="line"><span class="comment">//response.getWriter().write("json串");</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h2><p>springmvc参数绑定过程：<br><strong>从客户端请求key/value数据，经过参数绑定，将key/value数据绑定到controller方法的形参上。接收页面提交的数据是通过方法形参来接收，而不是在controller类定义成员变量接收。</strong></p><h3 id="默认支持的类型"><a href="#默认支持的类型" class="headerlink" title="默认支持的类型"></a>默认支持的类型</h3><p>处理器形参中添加如下类型的参数，处理适配器会默认识别并进行赋值。</p><ul><li>HttpServletRequest</li><li>HttpServletResponse</li><li>HttpSession</li><li>Model/ModelMap<h3 id="简单类型绑定"><a href="#简单类型绑定" class="headerlink" title="简单类型绑定"></a>简单类型绑定</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//限制http请求方法，可以post和get</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/editItems"</span>,method=RequestMethod.GET,RequestMethod.POST&#125; )</span><br><span class="line"><span class="comment">//@RequestParam里边指定request传入参数名称和形参进行绑定。</span></span><br><span class="line"><span class="comment">//通过required属性指定参数是否必须要传入,默认为true</span></span><br><span class="line"><span class="comment">//通过defaultValue可以设置默认值，如果id参数没有传入，将默认值和形参绑定。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">editItems</span><span class="params">(Model model,</span></span></span><br><span class="line"><span class="function"><span class="params">@RequestParam(value=<span class="string">"id"</span>,defaultValue=<span class="string">"2"</span>)</span> Integer idd) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ItemsCustom itemsCustom = itemsService.findItemsById(idd);</span><br><span class="line">model.addAttribute(<span class="string">"itemsCustom"</span>, itemsCustom);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"/items/editItems"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果不使用@RequestParam，要求request传入参数名称和controller方法的形参名称一致，方可绑定成功。</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/editItems"</span>,method=RequestMethod.GET,RequestMethod.POST&#125; )</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">editItems</span><span class="params">(Model model,Integer id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ItemsCustom itemsCustom = itemsService.findItemsById(id);</span><br><span class="line">model.addAttribute(<span class="string">"itemsCustom"</span>, itemsCustom);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"/items/editItems"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;form id=<span class="string">"itemForm"</span> action=<span class="string">"$&#123;pageContext.request.contextPath&#125;/items/editItemsSubmit.action"</span> method=<span class="string">"post"</span> &gt;</span><br><span class="line">&lt;input type=<span class="string">"hidden"</span> name=<span class="string">"id"</span> value=<span class="string">"$&#123;itemsCustom.id &#125;"</span>/&gt;</span><br><span class="line">修改商品信息：</span><br><span class="line">&lt;table width=<span class="string">"100%"</span> border=<span class="number">1</span>&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;商品名称&lt;/td&gt;</span><br><span class="line">&lt;td&gt;&lt;input type="text" name="name" value="$&#123;itemsCustom.name &#125;"/&gt;&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;商品价格&lt;/td&gt;</span><br><span class="line">&lt;td&gt;&lt;input type="text" name="price" value="$&#123;itemsCustom.price &#125;"/&gt;&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><h3 id="POJO类型绑定"><a href="#POJO类型绑定" class="headerlink" title="POJO类型绑定"></a>POJO类型绑定</h3><h4 id="简单POJO绑定"><a href="#简单POJO绑定" class="headerlink" title="简单POJO绑定"></a>简单POJO绑定</h4><p>将pojo对象中的属性名与传递进来的参数名对应<br>如果传进来的参数名称和对象中的属性名称一致，则将参数值设置在pojo对象中<br><img src="/2018/07/27/SpringMVC/pojo简单类型.png" title="jsp传进的数据"><br><img src="/2018/07/27/SpringMVC/entity.png" title="pojo类（实体类）"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/editItemsSubmit"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">editItemsSubmit</span><span class="params">(Integer id,ItemsCustom itemsCustom)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">itemsService.updateItems(id, itemsCustom);</span><br><span class="line"><span class="comment">//return "forward:queryItems.action";</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="包装POJO绑定"><a href="#包装POJO绑定" class="headerlink" title="包装POJO绑定"></a>包装POJO绑定</h4><p>将pojo对象作为一个包装对象的属性，controller方法中以该包装对象作为形参。<br><img src="/2018/07/27/SpringMVC/包装pojo绑定.png" title="ItemsQueryVo"></p><img src="/2018/07/27/SpringMVC/图片1.png" title="jsp页面"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包装的POJO绑定</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/queryItems"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">queryItems</span><span class="params">(HttpServletRequest request,ItemsQueryVo itemsQueryVo)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="comment">//调用service查找 数据库，查询商品列表</span></span><br><span class="line">List&lt;ItemsCustom&gt; itemsList = <span class="keyword">new</span> ArrayList&lt;ItemsCustom&gt;();</span><br><span class="line">itemsList = itemsService.findItemsList(itemsQueryVo);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回ModelAndView</span></span><br><span class="line">ModelAndView modelAndView =  <span class="keyword">new</span> ModelAndView();</span><br><span class="line"><span class="comment">//相当 于request的setAttribut，在jsp页面中通过itemsList取数据</span></span><br><span class="line">modelAndView.addObject(<span class="string">"itemsList"</span>, itemsList);</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定视图</span></span><br><span class="line"><span class="comment">//modelAndView.setViewName("/WEB-INF/jsp/items/itemsList.jsp");</span></span><br><span class="line">modelAndView.setViewName(<span class="string">"items/itemsList"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义参数绑定"><a href="#自定义参数绑定" class="headerlink" title="自定义参数绑定"></a>自定义参数绑定</h4><p>例子：<br>自定义参数绑定，将日期串转成java.util.Date类型</p><p>1–自定义Converter，实现Converter接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.convert.converter.Converter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomDateConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>,<span class="title">Date</span>&gt;</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> sdf.parse(source);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2–需要向处理器适配器中注入自定义的参数绑定组件。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;mvc:annotation-driven conversion-service="conversionService"&gt;&lt;/mvc:annotation-driven&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 自定义参数绑定 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"conversionService"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.format.support.FormattingConversionServiceFactoryBean"</span>&gt;</span><br><span class="line">&lt;!-- 转换器 --&gt;</span><br><span class="line">&lt;property name=<span class="string">"converters"</span>&gt;</span><br><span class="line">&lt;list&gt;</span><br><span class="line">&lt;!-- 日期类型转换 --&gt;</span><br><span class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.neuedu.controller.converter.CustomDateConverter"</span>/&gt;</span><br><span class="line">&lt;/list&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h4 id="集合类型绑定"><a href="#集合类型绑定" class="headerlink" title="集合类型绑定"></a>集合类型绑定</h4><p>List中存放对象，并将定义的List放在包装类中，controller方法中使用包装对象接收。<br>例如：商品的批量修改</p><img src="/2018/07/27/SpringMVC/图片2.png" title="ItemsQueryVo"><img src="/2018/07/27/SpringMVC/图片3.png" title="List"><img src="/2018/07/27/SpringMVC/图片4.png" title="controller方法">]]></content>
      
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring</title>
      <link href="/2018/07/27/Spring/"/>
      <url>/2018/07/27/Spring/</url>
      
        <content type="html"><![CDATA[<p>spring是一个开源的JavaEE框架，因它使用面向接口的编程思想贯穿整个系统应用，解决是业务逻辑层和其他各层的松耦合问题，它包括7大模块，Spring Core、Spring Context、Spring AOP、Spring DAO、Spring ORM、Spring Web 、Spring MVC </p><a id="more"></a><h2 id="Spring容器和bean原理"><a href="#Spring容器和bean原理" class="headerlink" title="Spring容器和bean原理"></a>Spring容器和bean原理</h2><h3 id="传统组件调用方式"><a href="#传统组件调用方式" class="headerlink" title="传统组件调用方式"></a>传统组件调用方式</h3><p>代码之间的依赖性较强，需要一个组件时要new出来该组件的对象</p><pre><code>public class Bussiness{    private UserDao=new UserDao();    public List getPage(){        return this.Dao.query();    }}</code></pre><h3 id="解决方法——–利用IoC（Invention-of-Control-控制反转）解耦"><a href="#解决方法——–利用IoC（Invention-of-Control-控制反转）解耦" class="headerlink" title="解决方法——–利用IoC（Invention of Control,控制反转）解耦"></a>解决方法——–利用IoC（Invention of Control,控制反转）解耦</h3><p>IoC是一种设计原则，常见的方式时依赖注入（DI）。组件不再由应用程序创建，而是由IoC容器负责，容器在实例化对象时，主动地将它所依赖的对象注入给它，应用程序只需直接使用已经创建并配置好的组件即可。spring就是一个IoC容器。</p><h4 id="实例化IoC容器—BeanFactory"><a href="#实例化IoC容器—BeanFactory" class="headerlink" title="实例化IoC容器—BeanFactory"></a>实例化IoC容器—BeanFactory</h4><pre><code>BeanFactory factory=new XMLBeanFactory(new FileInputStream(&quot;beans.xml&quot;));</code></pre><h4 id="实例化IoC容器—ApplicationContext-常用"><a href="#实例化IoC容器—ApplicationContext-常用" class="headerlink" title="实例化IoC容器—ApplicationContext (常用)"></a>实例化IoC容器—ApplicationContext (常用)</h4><pre><code>ApplicationContext apc = new ClassPathXmlApplicationContext(&quot;application.xml&quot;);</code></pre><h4 id="BeanFactory-与ApplicationContext-区别"><a href="#BeanFactory-与ApplicationContext-区别" class="headerlink" title="BeanFactory 与ApplicationContext 区别"></a>BeanFactory 与ApplicationContext 区别</h4><p>BeanFactory直到第一次使用getBean()获取bean实例时才会创建bean,ApplicationContext 在自身被实例化时就一次完成所有的bean的创建</p><h4 id="Bean的定义"><a href="#Bean的定义" class="headerlink" title="Bean的定义"></a>Bean的定义</h4><pre><code>&lt;bean id=&quot;people&quot; class=&quot;com.soft.ch01.Customer&quot;lazy-init=&quot;false&quot;init-method=&quot;init&quot;destroy-method=&quot;deestroy&quot;scope=&quot;prototype&quot;&gt;&lt;/bean&gt;</code></pre><h4 id="Bean的获取"><a href="#Bean的获取" class="headerlink" title="Bean的获取"></a>Bean的获取</h4><pre><code>apc.getBean(&quot;people&quot;)  ;                 </code></pre><h2 id="依赖注入的实现"><a href="#依赖注入的实现" class="headerlink" title="依赖注入的实现"></a>依赖注入的实现</h2><h2 id="面向切面的编程AOP"><a href="#面向切面的编程AOP" class="headerlink" title="面向切面的编程AOP"></a>面向切面的编程AOP</h2><h3 id="AOP是什么"><a href="#AOP是什么" class="headerlink" title="AOP是什么"></a>AOP是什么</h3><p>面向切面编程(aspect oriented programming)<br>(AOP介绍：<a href="https://www.cnblogs.com/Wolfmanlq/p/6036019.html" target="_blank" rel="noopener">https://www.cnblogs.com/Wolfmanlq/p/6036019.html</a>)<br>OOP（Object Oriented Programming）引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。<br>AOP技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。</p><p>使用”横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。<br>Spring AOP的出现时为了取代EJB的事务机制;<br>(EJB介绍：<a href="https://www.cnblogs.com/EasonJim/p/7103546.html" target="_blank" rel="noopener">https://www.cnblogs.com/EasonJim/p/7103546.html</a>)</p><h3 id="AOP涉及的概念"><a href="#AOP涉及的概念" class="headerlink" title="AOP涉及的概念"></a>AOP涉及的概念</h3><p><a href="https://www.cnblogs.com/liuruowang/p/5711563.html" target="_blank" rel="noopener">https://www.cnblogs.com/liuruowang/p/5711563.html</a></p><ul><li>Aspect：（切面）</li><li>Joinpoint（连接点）</li><li>Pointcut（切入点）</li><li>Advice（通知）</li><li>Target（目标对象）</li><li>Weave（织入）</li><li>Introduction(引入)<br>切面aspect：就是公共操作的集合类，包含处理前操作，处理后操作；<br>切点pointcut：就是需要公共操作的方法集；比如adduser；addbook…..</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JDBC</title>
      <link href="/2018/07/27/JDBC/"/>
      <url>/2018/07/27/JDBC/</url>
      
        <content type="html"><![CDATA[<p>一些关于jdbc封装的知识以及jdbc的一些基本方法和实现步骤<br><a id="more"></a></p><h3 id="DBUtils-java"><a href="#DBUtils-java" class="headerlink" title="DBUtils.java"></a>DBUtils.java</h3><h4 id="getConnection-的封装："><a href="#getConnection-的封装：" class="headerlink" title="getConnection()的封装："></a>getConnection()的封装：</h4><pre><code>线程实现系统只有一个connection--------ThreadLocalconn=DriverManager.getConnection(url, username,password);</code></pre><h4 id="事务开启的封装（）："><a href="#事务开启的封装（）：" class="headerlink" title="事务开启的封装（）："></a>事务开启的封装（）：</h4><pre><code>getConnection().setAutoCommit(false);</code></pre><h4 id="事务提交的封装（）："><a href="#事务提交的封装（）：" class="headerlink" title="事务提交的封装（）："></a>事务提交的封装（）：</h4><pre><code>getConnection().commit();</code></pre><h4 id="事务的回滚："><a href="#事务的回滚：" class="headerlink" title="事务的回滚："></a>事务的回滚：</h4><pre><code>getConnection().rollback();</code></pre><h4 id="事务的结束"><a href="#事务的结束" class="headerlink" title="事务的结束"></a>事务的结束</h4><pre><code>getConnection().setAutoCommit(True);</code></pre><h4 id="SQL语句的编译的封装："><a href="#SQL语句的编译的封装：" class="headerlink" title="SQL语句的编译的封装："></a>SQL语句的编译的封装：</h4><pre><code>getConnection().prepareStatement(sql);</code></pre><h4 id="资源销毁的封装："><a href="#资源销毁的封装：" class="headerlink" title="资源销毁的封装："></a>资源销毁的封装：</h4><pre><code>ResultSet.close()PrepareStatement.close();Connection.close();</code></pre><h3 id="PstmBean-java"><a href="#PstmBean-java" class="headerlink" title="PstmBean.java:"></a>PstmBean.java:</h3><h4 id="用于PreparedStatement语句的封装："><a href="#用于PreparedStatement语句的封装：" class="headerlink" title="用于PreparedStatement语句的封装："></a>用于PreparedStatement语句的封装：</h4><pre><code>PreparedStatement.executeUpdate();单条SQL语句的执行PreparedStatement.executeBatch();批量处理SQL语句PreparedStatement.close();</code></pre><h3 id="PersonServicesSupport-java用于person表的jdbc处理封装"><a href="#PersonServicesSupport-java用于person表的jdbc处理封装" class="headerlink" title="PersonServicesSupport.java用于person表的jdbc处理封装"></a>PersonServicesSupport.java用于person表的jdbc处理封装</h3><h3 id="Preparedstatement操作流程："><a href="#Preparedstatement操作流程：" class="headerlink" title="Preparedstatement操作流程："></a>Preparedstatement操作流程：</h3><pre><code>//1--SQL语句的编译//SQL语句类似于//select name,age,gender //  From  person// Where id=?PreparedStatement pstm=Connection.preparedStatement(sql);//2—-对SQL语句中的”?”进行赋值(两种执行方式，批量处理与非批量处理)//2.1非批量处理Pstm.setObject(index,value);    //2.2批量处理    For(循环){    Pstm.setObject(index,value);        Pstm.addBatch();}//3—执行SQL语句(两种执行方式，批量处理与非批量处理)//3.1非批量处理Pstm.excuteUpdate();    //3.2批量处理        Pstm.excuteBatch();        Connection.commit();</code></pre><h3 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h3><h4 id="接口："><a href="#接口：" class="headerlink" title="接口："></a>接口：</h4><pre><code>一般用于声明方法，其中有些方法子类不用实现的可以使用default关键字实现子类的默认实现，即接口一般是抽象方法的集合；</code></pre><h4 id="抽象类："><a href="#抽象类：" class="headerlink" title="抽象类："></a>抽象类：</h4><pre><code>不用实例化对象，只用于子类实现的细节的类；它可以存在属性，方法一般声明为protect final</code></pre><h3 id="数据的传递交换"><a href="#数据的传递交换" class="headerlink" title="数据的传递交换"></a>数据的传递交换</h3><h4 id="Web应用的数据的流动过程："><a href="#Web应用的数据的流动过程：" class="headerlink" title="Web应用的数据的流动过程："></a>Web应用的数据的流动过程：</h4><pre><code>从jsp页面中通过request传递给servlet，得到数据request.getParameterMap()）解析为HashMap(String,Object)类型的DTO，之后调用service中的SQL语句，之后在servlet中将SQL结果通过request.SetAttibute()传递给页面，页面通过EL语言解析显示数据到页面；</code></pre><h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><pre><code>从网页中利用getParameterMap()获得Map&lt;String,String[]&gt;的类型的数据，将其解析为Map&lt;String,String&gt;类型的dto对象</code></pre><h4 id="Servlet的封装"><a href="#Servlet的封装" class="headerlink" title="Servlet的封装"></a>Servlet的封装</h4><pre><code>接口：规定子类要实现的方法抽象类：对接口的方法实现过程的细化，留给具体类使用具体类：抽象类（父类）的方法的调用</code></pre><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><pre><code>获得从servlet中的解析得到的dto对象。对sql语句的参数赋值 </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/07/26/hello-world/"/>
      <url>/2018/07/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
  
  
</search>
